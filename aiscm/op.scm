(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm mem)
  #:use-module (aiscm jit)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm sequence)
  #:export (fill)
  #:re-export (+ -))
(define ctx (make <jit-context>))
(define-method (fill (t <meta<element>>) (n <integer>) value)
  (let* [(tr    (sequence t))
         (step  (storage-size (typecode tr)))
         (ptr   (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) step))
         (dx    (reg step RDX))
         (code  (asm ctx void (list (LEA RCX (ptr RDI RSI (scale step)))
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV (ptr RDI) dx)
                                    (ADD RDI step)
                                    (CMP RDI RCX)
                                    (JNE 'loop)
                                    'ret
                                    (RET))
                     int64 int int))
         (proc  (lambda (t n value)
                  (let* [(r  (make tr #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))]
                    (code pr n value)
                    r)))]
    (add-method! fill (make <method>
                            #:specializers (list (class-of t) <integer> (class-of value))
                            #:procedure proc))
    (fill t n value)))
(define-method (+ (a <element>)) a)
(define-method (+ (a <element>) (b <element>))
  (let* [(ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (step   (storage-size tr))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (reg step RAX))
         (di     (reg step RDI))
         (si     (reg step RSI))
         (code   (asm ctx ftr (list (MOV ax di) (ADD ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b)))))]
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <integer>))
  (+ a (make (match b) #:value b)))
(define-method (+ (a <integer>) (b <element>))
  (+ (make (match a) #:value a) b))
(define-method (+ (a <sequence<>>) (b <element>))
  (let* [(ta    (class-of a))
         (tb    (class-of b))
         (tr    (coerce ta tb))
         (ftb   (foreign-type tb))
         (stepa (storage-size (typecode ta)))
         (stepr (storage-size (typecode tr)))
         (mova  (if (eq? (typecode ta) (typecode tr)) MOV (if (signed? (typecode ta)) MOVSX MOVZX)))
         (aptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepa))
         (rptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepr))
         (axa   (reg stepa RAX))
         (axr   (reg stepr RAX))
         (dx    (reg stepr RDX))
         (code  (asm ctx void (list (LEA R8 (rptr RDI RCX (scale stepr)))
                                    (CMP RDI R8)
                                    (JE 'ret)
                                    'loop
                                    (mova axr (aptr RSI))
                                    (ADD axr dx)
                                    (MOV (rptr RDI) axr)
                                    (ADD RDI stepr)
                                    (ADD RSI stepa)
                                    (CMP R8 RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 ftb int))
         (proc  (lambda (a b)
                  (let* [(n (get-size a))
                         (r (make tr #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pa ((compose pointer-address get-memory get-value get-value) a))]
                    (code pr pa (get-value b) n)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <sequence<>>))
  (let* [(ta    (class-of a))
         (tb    (class-of b))
         (tr    (coerce ta tb))
         (fta   (foreign-type ta))
         (stepb (storage-size (typecode tb)))
         (stepr (storage-size (typecode tr)))
         (movb  (if (eq? (typecode tb) (typecode tr)) MOV (if (signed? (typecode tb)) MOVSX MOVZX)))
         (bptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepb))
         (rptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepr))
         (axb   (reg stepb RAX))
         (axr   (reg stepr RAX))
         (si    (reg stepr RSI))
         (code  (asm ctx void (list (LEA R8 (rptr RDI RCX (scale stepr)))
                                    (CMP RDI R8)
                                    (JE 'ret)
                                    'loop
                                    (movb axr (bptr RDX))
                                    (ADD axr si)
                                    (MOV (rptr RDI) axr)
                                    (ADD RDI stepr)
                                    (ADD RDX stepb)
                                    (CMP R8 RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 fta int64 int))
         (proc  (lambda (a b)
                  (let* [(n  (get-size b))
                         (r  (make tr #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pb ((compose pointer-address get-memory get-value get-value) b))]
                    (code pr (get-value a) pb n)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <sequence<>>) (b <sequence<>>))
  (let* [(ta    (class-of a))
         (tb    (class-of b))
         (tr    (coerce ta tb))
         (stepa (storage-size (typecode ta)))
         (stepb (storage-size (typecode tb)))
         (stepr (storage-size (typecode tr)))
         (mova  (if (eq? (typecode ta) (typecode tr)) MOV (if (signed? (typecode ta)) MOVSX MOVZX)))
         (aptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepa))
         (bptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepb))
         (rptr  (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) stepr))
         (axa   (reg stepa RAX))
         (axr   (reg stepr RAX))
         (bxr   (reg stepr RBX))
         (code  (asm ctx void (list (LEA R8 (rptr RDI RCX (scale stepr)))
                                    (CMP RDI R8)
                                    (JE 'ret)
                                    'loop
                                    (mova axr (aptr RSI))
                                    (if (eq? (typecode tb) (typecode tr))
                                      (ADD axr (bptr RDX))
                                      (append
                                        ((if (signed? (typecode tb)) MOVSX MOVZX) bxr (bptr RDX))
                                        (ADD axr bxr)))
                                    (MOV (rptr RDI) axr)
                                    (ADD RDI stepr)
                                    (ADD RSI stepa)
                                    (ADD RDX stepb)
                                    (CMP R8 RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 int64 int))
         (proc  (lambda (a b)
                  (let* [(na (get-size a))
                         (nb (get-size b))
                         (r  (make tr #:size na))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pa ((compose pointer-address get-memory get-value get-value) a))
                         (pb ((compose pointer-address get-memory get-value get-value) b))]
                    (if (not (= na nb)) (throw 'array-dimensions-different na nb))
                    (code pr pa pb na)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (- (a <element>))
  (let* [(t      (class-of a))
         (ft     (foreign-type t))
         (ax     (if (eqv? (bits t) 64) RAX EAX))
         (di     (if (eqv? (bits t) 64) RDI EDI))
         (code   (asm ctx ft (list (MOV ax di) (NEG ax) (RET)) ft))
         (proc   (lambda (a) (make t #:value (code (get-value a)))))]
    (add-method! - (make <method>
                         #:specializers (list t)
                         #:procedure proc))
    (- a)))
(define-method (- (a <sequence<>>))
  (let* [(ta    (class-of a))
         (tr    ta)
         (step  (storage-size (typecode tr)))
         (ptr   (assq-ref (list (cons 1 byte-ptr) (cons 2 word-ptr) (cons 4 dword-ptr) (cons 8 qword-ptr)) step))
         (ax    (reg step RAX))
         (code  (asm ctx void (list (LEA RCX (ptr RDI RDX (scale step)))
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV ax (ptr RSI))
                                    (NEG ax)
                                    (MOV (ptr RDI) ax)
                                    (ADD RDI step)
                                    (ADD RSI step)
                                    (CMP RCX RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 int))
         (proc (lambda (a)
                 (let* [(n  (get-size a))
                        (r  (make tr #:size n))
                        (pr ((compose pointer-address get-memory get-value get-value) r))
                        (pa ((compose pointer-address get-memory get-value get-value) a))]
                   (code pr pa n)
                   r)))]
    (add-method! - (make <method>
                         #:specializers (list ta)
                         #:procedure proc))
    (- a)))
(define-method (- (a <element>) (b <element>))
  (let* [(ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (step   (storage-size tr))
         (ax     (reg step RAX))
         (di     (reg step RDI))
         (si     (reg step RSI))
         (code   (asm ctx ftr (list (MOV ax di) (SUB ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b)))))]
    (add-method! - (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (- a b)))
(define-method (- (a <element>) (b <integer>))
  (- a (make (match b) #:value b)))
(define-method (- (a <integer>) (b <element>))
  (- (make (match a) #:value a) b))
