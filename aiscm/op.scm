(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm mem)
  #:use-module (aiscm jit)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm sequence)
  #:export (fill)
  #:re-export (+ -))
(define ctx (make <jit-context>))
(define-method (fill (t <meta<element>>) (n <integer>) value)
  (let* [(step  (storage-size t))
         (dx    (reg t RDX))
         (code  (asm ctx void (list (LEA RCX (ptr t RDI RSI (scale step)))
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV (ptr t RDI) dx)
                                    (ADD RDI step)
                                    (CMP RDI RCX)
                                    (JNE 'loop)
                                    'ret
                                    (RET))
                     int64 int int))
         (proc  (lambda (t n value)
                  (let* [(r  (make (sequence t) #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))]
                    (code pr n value)
                    r)))]
    (add-method! fill (make <method>
                            #:specializers (list (class-of t) <integer> (class-of value))
                            #:procedure proc))
    (fill t n value)))
(define-method (+ (a <element>)) a)
(define-method (+ (a <element>) (b <element>))
  (let* [(ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (reg tr RAX))
         (di     (reg tr RDI))
         (si     (reg tr RSI))
         (code   (asm ctx ftr (list (MOV ax di) (ADD ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b)))))]
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <integer>))
  (+ a (make (match b) #:value b)))
(define-method (+ (a <integer>) (b <element>))
  (+ (make (match a) #:value a) b))
(define-method (+ (a <sequence<>>) (b <element>))
  (let* [(ta    (typecode (class-of a)))
         (tb    (class-of b))
         (tr    (coerce ta tb))
         (ftb   (foreign-type tb))
         (stepa (storage-size ta))
         (stepr (storage-size tr))
         (mova  (if (eq? ta tr) MOV (if (signed? ta) MOVSX MOVZX)))
         (axa   (reg ta RAX))
         (axr   (reg tr RAX))
         (dx    (reg tr RDX))
         (code  (asm ctx void (list (LEA R8 (ptr tr RDI RCX (scale stepr)))
                                    (CMP RDI R8)
                                    (JE 'ret)
                                    'loop
                                    (mova axr (ptr ta RSI))
                                    (ADD axr dx)
                                    (MOV (ptr tr RDI) axr)
                                    (ADD RDI stepr)
                                    (ADD RSI stepa)
                                    (CMP R8 RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 ftb int))
         (proc  (lambda (a b)
                  (let* [(n (get-size a))
                         (r (make (sequence tr) #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pa ((compose pointer-address get-memory get-value get-value) a))]
                    (code pr pa (get-value b) n)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list (sequence ta) tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <sequence<>>))
  (let* [(ta    (class-of a))
         (tb    (typecode (class-of b)))
         (tr    (coerce ta tb))
         (fta   (foreign-type ta))
         (stepb (storage-size tb))
         (stepr (storage-size tr))
         (movb  (if (eq? tb tr) MOV (if (signed? tb) MOVSX MOVZX)))
         (axb   (reg tb RAX))
         (axr   (reg tr RAX))
         (si    (reg tr RSI))
         (code  (asm ctx void (list (LEA R8 (ptr tr RDI RCX (scale stepr)))
                                    (CMP RDI R8)
                                    (JE 'ret)
                                    'loop
                                    (movb axr (ptr tb RDX))
                                    (ADD axr si)
                                    (MOV (ptr tr RDI) axr)
                                    (ADD RDI stepr)
                                    (ADD RDX stepb)
                                    (CMP R8 RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 fta int64 int))
         (proc  (lambda (a b)
                  (let* [(n  (get-size b))
                         (r  (make (sequence tr) #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pb ((compose pointer-address get-memory get-value get-value) b))]
                    (code pr (get-value a) pb n)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list ta (sequence tb))
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <sequence<>>) (b <sequence<>>))
  (let* [(ta    (typecode (class-of a)))
         (tb    (typecode (class-of b)))
         (tr    (coerce ta tb))
         (stepa (storage-size ta))
         (stepb (storage-size tb))
         (stepr (storage-size tr))
         (mova  (if (eq? ta tr) MOV (if (signed? ta) MOVSX MOVZX)))
         (axa   (reg ta RAX))
         (axr   (reg tr RAX))
         (bxr   (reg tr RBX))
         (code  (asm ctx void (list (LEA R8 (ptr tr RDI RCX (scale stepr)))
                                    (CMP RDI R8)
                                    (JE 'ret)
                                    'loop
                                    (mova axr (ptr ta RSI))
                                    (if (eq? tb tr)
                                      (ADD axr (ptr tb RDX))
                                      (append
                                        ((if (signed? tb) MOVSX MOVZX) bxr (ptr tb RDX))
                                        (ADD axr bxr)))
                                    (MOV (ptr tr RDI) axr)
                                    (ADD RDI stepr)
                                    (ADD RSI stepa)
                                    (ADD RDX stepb)
                                    (CMP R8 RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 int64 int))
         (proc  (lambda (a b)
                  (let* [(na (get-size a))
                         (nb (get-size b))
                         (r  (make (sequence tr) #:size na))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pa ((compose pointer-address get-memory get-value get-value) a))
                         (pb ((compose pointer-address get-memory get-value get-value) b))]
                    (if (not (= na nb)) (throw 'array-dimensions-different na nb))
                    (code pr pa pb na)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list (sequence ta) (sequence tb))
                         #:procedure proc))
    (+ a b)))
(define-method (- (a <element>))
  (let* [(t      (class-of a))
         (ft     (foreign-type t))
         (ax     (if (eqv? (bits t) 64) RAX EAX))
         (di     (if (eqv? (bits t) 64) RDI EDI))
         (code   (asm ctx ft (list (MOV ax di) (NEG ax) (RET)) ft))
         (proc   (lambda (a) (make t #:value (code (get-value a)))))]
    (add-method! - (make <method>
                         #:specializers (list t)
                         #:procedure proc))
    (- a)))
(define-method (- (a <sequence<>>))
  (let* [(t     (typecode (class-of a)))
         (step  (storage-size t))
         (ax    (reg t RAX))
         (code  (asm ctx void (list (LEA RCX (ptr t RDI RDX (scale step)))
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV ax (ptr t RSI))
                                    (NEG ax)
                                    (MOV (ptr t RDI) ax)
                                    (ADD RDI step)
                                    (ADD RSI step)
                                    (CMP RCX RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 int))
         (proc (lambda (a)
                 (let* [(n  (get-size a))
                        (r  (make (sequence t) #:size n))
                        (pr ((compose pointer-address get-memory get-value get-value) r))
                        (pa ((compose pointer-address get-memory get-value get-value) a))]
                   (code pr pa n)
                   r)))]
    (add-method! - (make <method>
                         #:specializers (list (sequence t))
                         #:procedure proc))
    (- a)))
(define-method (- (a <element>) (b <element>))
  (let* [(ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (step   (storage-size tr))
         (ax     (reg step RAX))
         (di     (reg step RDI))
         (si     (reg step RSI))
         (code   (asm ctx ftr (list (MOV ax di) (SUB ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b)))))]
    (add-method! - (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (- a b)))
(define-method (- (a <element>) (b <integer>))
  (- a (make (match b) #:value b)))
(define-method (- (a <integer>) (b <element>))
  (- (make (match a) #:value a) b))
