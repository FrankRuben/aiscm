(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm mem)
  #:use-module (aiscm jit)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm sequence)
  #:export (fill! neg)
  #:re-export (+ -))
(define ctx (make <jit-context>))
(define-method (fill! (a <sequence<>>) b)
  (let* ((ta    (class-of a))
         (tb    (class-of b))
         (tr    ta)
         (step  (storage-size (typecode tr)))
         (scale (assq-ref (list (cons 1 *1) (cons 2 *2) (cons 4  *4) (cons 8 *8)) step))
         (dx    (assq-ref (list (cons 1 DL) (cons 2 DX) (cons 4 EDX) (cons 8 RDX)) step))
         (code  (asm ctx void (list (LEA RCX *RDI RSI scale)
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV *RDI dx)
                                    (ADD RDI step)
                                    (CMP RDI RCX)
                                    (JNE 'loop)
                                    'ret
                                    (RET))
                     int64 int int))
         (proc  (lambda (a b)
                  (let ((n   (get-size a))
                        (ptr ((compose pointer-address get-memory get-value get-value) a)))
                    (code ptr n b)
                    a))))
    (add-method! fill! (make <method>
                             #:specializers (list ta tb)
                             #:procedure proc))
    (fill! a b)))
(define-method (+ (a <element>)) a)
(define-method (+ (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (ADD ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <integer>))
  (+ a (make (match b) #:value b)))
(define-method (+ (a <integer>) (b <element>))
  (+ (make (match a) #:value a) b))
(define-method (- (a <element>))
  (let* ((t      (class-of a))
         (ft     (foreign-type t))
         (ax     (if (eqv? (bits t) 64) RAX EAX))
         (di     (if (eqv? (bits t) 64) RDI EDI))
         (code   (asm ctx ft (list (MOV ax di) (NEG ax) (RET)) ft))
         (proc   (lambda (a) (make t #:value (code (get-value a))))))
    (add-method! - (make <method>
                         #:specializers (list t)
                         #:procedure proc))
    (- a)))
(define-method (neg (a <sequence<>>))
  (let* ((ta    (class-of a))
         (tr    ta)
         (step  (storage-size (typecode tr)))
         (scale (assq-ref (list (cons 1 *1) (cons 2 *2) (cons 4  *4) (cons 8 *8)) step))
         (ax    (assq-ref (list (cons 1 AL) (cons 2 AX) (cons 4 EAX) (cons 8 RAX)) step))
         (code  (asm ctx void (list (LEA RCX *RDI EDX scale)
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV ax *RSI)
                                    (NEG ax)
                                    (MOV *RDI ax)
                                    (ADD RDI step)
                                    (ADD RSI step)
                                    (CMP RCX RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET)) int64 int64 int))
         (proc (lambda (a)
                 (let* ((n (get-size a))
                        (r (make (class-of a) #:size n))
                        (p ((compose pointer-address get-memory get-value get-value) r))
                        (q ((compose pointer-address get-memory get-value get-value) a)))
                   (code p q n)
                   r))))
    (add-method! neg (make <method>
                           #:specializers (list ta)
                           #:procedure proc))
    (neg a)))
(define-method (- (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (SUB ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! - (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (- a b)))
(define-method (- (a <element>) (b <integer>))
  (- a (make (match b) #:value b)))
(define-method (- (a <integer>) (b <element>))
  (- (make (match a) #:value a) b))
