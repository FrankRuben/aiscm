(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm mem)
  #:use-module (aiscm jit)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm sequence)
  #:export (fill!)
  #:re-export (+ -))
(define ctx (make <jit-context>))
(define-method (fill! (a <element>) b)
  (let* ((ta    (class-of a))
         (tb    (class-of b))
         (tr    ta)
         (code  (asm ctx void (list (LEA RCX *RDI RSI *4)
                                    (CMP RDI RCX)
                                    (JE 'ret)
                                    'loop
                                    (MOV *RDI EDX)
                                    (ADD RDI 4)
                                    (CMP RCX RDI)
                                    (JNE 'loop)
                                    'ret
                                    (RET))
                     int64 int int))
         (proc  (lambda (a b)
                  (let ((ptr ((compose pointer-address get-memory get-value get-value) a))
                        (n   (get-size a)))
                  (code ptr n b)
                  a))))
    (add-method! fill! (make <method>
                             #:specializers (list ta tb)
                             #:procedure proc))
    (fill! a b)))
(define-method (+ (a <element>)) a)
(define-method (+ (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (ADD ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <integer>))
  (+ a (make (match b) #:value b)))
(define-method (+ (a <integer>) (b <element>))
  (+ (make (match a) #:value a) b))
(define-method (- (a <element>))
  (let* ((t      (class-of a))
         (ft     (foreign-type t))
         (ax     (if (eqv? (bits t) 64) RAX EAX))
         (di     (if (eqv? (bits t) 64) RDI EDI))
         (code   (asm ctx ft (list (MOV ax di) (NEG ax) (RET)) ft))
         (proc   (lambda (a) (make t #:value (code (get-value a))))))
    (add-method! - (make <method>
                         #:specializers (list t)
                         #:procedure proc))
    (- a)))
(define-method (- (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (SUB ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! - (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (- a b)))
(define-method (- (a <element>) (b <integer>))
  (- a (make (match b) #:value b)))
(define-method (- (a <integer>) (b <element>))
  (- (make (match a) #:value a) b))
