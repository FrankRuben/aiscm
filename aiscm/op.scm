(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm mem)
  #:use-module (aiscm jit)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm sequence)
  #:export (fill)
  #:re-export (+ -))
(define ctx (make <jit-context>))
(define-method (fill (t <meta<element>>) (n <integer>) value)
  (let* [(dx    (reg t RDX))
         (code  (asm ctx <null> (list (LEA RCX (ptr t RDI RSI (scale t)))
                                      (CMP RDI RCX)
                                      (JE 'ret)
                                      'loop
                                      (MOV (ptr t RDI) dx)
                                      (ADD RDI (storage-size t))
                                      (CMP RDI RCX)
                                      (JNE 'loop)
                                      'ret
                                      (RET))
                     <long> <int> <int>))
         (proc  (lambda (t n value)
                  (let* [(r  (make (sequence t) #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))]
                    (code pr n value)
                    r)))]
    (add-method! fill (make <method>
                            #:specializers (list (class-of t) <integer> (class-of value))
                            #:procedure proc))
    (fill t n value)))
(define-method (+ (a <element>)) a)
(define-method (+ (a <element>) (b <element>))
  (let* [(ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (ax     (reg tr RAX))
         (di     (reg tr RDI))
         (si     (reg tr RSI))
         (code   (asm ctx tr (list (MOV ax di) (ADD ax si) (RET)) ta tb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b)))))]
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <integer>))
  (+ a (make (match b) #:value b)))
(define-method (+ (a <integer>) (b <element>))
  (+ (make (match a) #:value a) b))
(define-method (+ (a <sequence<>>) (b <element>))
  (let* [(ta    (typecode (class-of a)))
         (tb    (class-of b))
         (tr    (coerce ta tb))
         (mova  (if (eq? ta tr) MOV (if (signed? ta) MOVSX MOVZX)))
         (axa   (reg ta RAX))
         (axr   (reg tr RAX))
         (dx    (reg tr RDX))
         (code  (asm ctx <null> (list (LEA R8 (ptr tr RDI RCX (scale tr)))
                                      (CMP RDI R8)
                                      (JE 'ret)
                                      'loop
                                      (mova axr (ptr ta RSI))
                                      (ADD axr dx)
                                      (MOV (ptr tr RDI) axr)
                                      (ADD RDI (storage-size tr))
                                      (ADD RSI (storage-size ta))
                                      (CMP R8 RDI)
                                      (JNE 'loop)
                                      'ret
                                      (RET)) <long> <long> tb <int>))
         (proc  (lambda (a b)
                  (let* [(n (get-size a))
                         (r (make (sequence tr) #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pa ((compose pointer-address get-memory get-value get-value) a))]
                    (code pr pa (get-value b) n)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list (sequence ta) tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <sequence<>>))
  (let* [(ta    (class-of a))
         (tb    (typecode (class-of b)))
         (tr    (coerce ta tb))
         (movb  (if (eq? tb tr) MOV (if (signed? tb) MOVSX MOVZX)))
         (axb   (reg tb RAX))
         (axr   (reg tr RAX))
         (si    (reg tr RSI))
         (code  (asm ctx <null> (list (LEA R8 (ptr tr RDI RCX (scale tr)))
                                      (CMP RDI R8)
                                      (JE 'ret)
                                      'loop
                                      (movb axr (ptr tb RDX))
                                      (ADD axr si)
                                      (MOV (ptr tr RDI) axr)
                                      (ADD RDI (storage-size tr))
                                      (ADD RDX (storage-size tb))
                                      (CMP R8 RDI)
                                      (JNE 'loop)
                                      'ret
                                      (RET)) <long> ta <long> <int>))
         (proc  (lambda (a b)
                  (let* [(n  (get-size b))
                         (r  (make (sequence tr) #:size n))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pb ((compose pointer-address get-memory get-value get-value) b))]
                    (code pr (get-value a) pb n)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list ta (sequence tb))
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <sequence<>>) (b <sequence<>>))
  (let* [(ta    (typecode (class-of a)))
         (tb    (typecode (class-of b)))
         (tr    (coerce ta tb))
         (mova  (if (eq? ta tr) MOV (if (signed? ta) MOVSX MOVZX)))
         (axa   (reg ta RAX))
         (axr   (reg tr RAX))
         (bxr   (reg tr RBX))
         (code  (asm ctx <null> (list (LEA R8 (ptr tr RDI RCX (scale tr)))
                                      (CMP RDI R8)
                                      (JE 'ret)
                                      'loop
                                      (mova axr (ptr ta RSI))
                                      (if (eq? tb tr)
                                        (ADD axr (ptr tb RDX))
                                        (append
                                          ((if (signed? tb) MOVSX MOVZX) bxr (ptr tb RDX))
                                          (ADD axr bxr)))
                                      (MOV (ptr tr RDI) axr)
                                      (ADD RDI (storage-size tr))
                                      (ADD RSI (storage-size ta))
                                      (ADD RDX (storage-size tb))
                                      (CMP R8 RDI)
                                      (JNE 'loop)
                                      'ret
                                      (RET)) <long> <long> <long> <int>))
         (proc  (lambda (a b)
                  (let* [(na (get-size a))
                         (nb (get-size b))
                         (r  (make (sequence tr) #:size na))
                         (pr ((compose pointer-address get-memory get-value get-value) r))
                         (pa ((compose pointer-address get-memory get-value get-value) a))
                         (pb ((compose pointer-address get-memory get-value get-value) b))]
                    (if (not (= na nb)) (throw 'array-dimensions-different na nb))
                    (code pr pa pb na)
                    r)))]
    (add-method! + (make <method>
                         #:specializers (list (sequence ta) (sequence tb))
                         #:procedure proc))
    (+ a b)))
(define-method (- (a <element>))
  (let* [(t      (class-of a))
         (ax     (if (eqv? (bits t) 64) RAX EAX))
         (di     (if (eqv? (bits t) 64) RDI EDI))
         (code   (asm ctx t (list (MOV ax di) (NEG ax) (RET)) t))
         (proc   (lambda (a) (make t #:value (code (get-value a)))))]
    (add-method! - (make <method>
                         #:specializers (list t)
                         #:procedure proc))
    (- a)))
(define-method (- (a <sequence<>>))
  (let* [(t     (typecode (class-of a)))
         (ax    (reg t RAX))
         (code  (asm ctx <null> (list (LEA RCX (ptr t RDI RDX (scale t)))
                                      (CMP RDI RCX)
                                      (JE 'ret)
                                      'loop
                                      (MOV ax (ptr t RSI))
                                      (NEG ax)
                                      (MOV (ptr t RDI) ax)
                                      (ADD RDI (storage-size t))
                                      (ADD RSI (storage-size t))
                                      (CMP RCX RDI)
                                      (JNE 'loop)
                                      'ret
                                      (RET)) <long> <long> <int>))
         (proc (lambda (a)
                 (let* [(n  (get-size a))
                        (r  (make (sequence t) #:size n))
                        (pr ((compose pointer-address get-memory get-value get-value) r))
                        (pa ((compose pointer-address get-memory get-value get-value) a))]
                   (code pr pa n)
                   r)))]
    (add-method! - (make <method>
                         #:specializers (list (sequence t))
                         #:procedure proc))
    (- a)))
(define-method (- (a <element>) (b <element>))
  (let* [(ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (ax     (reg tr RAX))
         (di     (reg tr RDI))
         (si     (reg tr RSI))
         (code   (asm ctx tr (list (MOV ax di) (SUB ax si) (RET)) ta tb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b)))))]
    (add-method! - (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (- a b)))
(define-method (- (a <element>) (b <integer>))
  (- a (make (match b) #:value b)))
(define-method (- (a <integer>) (b <element>))
  (- (make (match a) #:value a) b))
