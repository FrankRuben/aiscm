(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (srfi srfi-1)
  #:use-module (aiscm util)
  #:use-module (aiscm jit)
  #:use-module (aiscm mem)
  #:use-module (aiscm element)
  #:use-module (aiscm pointer)
  #:use-module (aiscm int)
  #:use-module (aiscm sequence)
  #:export (fill duplicate)
  #:re-export (+ - *))
(define ctx (make <jit-context>))

(define-method (unary-op (r_ <pointer<>>) (a_ <pointer<>>) op)
  (let [(r (make <var> #:type (typecode r_) #:symbol 'r ))]
     (list (MOV r (ptr (typecode a_) (get-value a_)))
           (op r)
           (MOV (ptr (typecode r_) (get-value r_)) r))))
(define-method (unary-op (r_ <sequence<>>) (a_ <sequence<>>) op)
  (let [(*r  (make <var> #:type <long> #:symbol '*r))
        (r+  (make <var> #:type <long> #:symbol 'r+))
        (n   (make <var> #:type <long> #:symbol 'n))
        (*a  (make <var> #:type <long> #:symbol '*a))
        (a+  (make <var> #:type <long> #:symbol 'a+))
        (*rx (make <var> #:type <long> #:symbol '*rx))]
    (list (MOV *r (get-value r_))
          (MOV r+ (last (strides r_)))
          (MOV n (last (shape r_)))
          (MOV *a (get-value a_))
          (MOV a+ (last (strides a_)))
          (IMUL n r+)
          (IMUL r+ r+ (size-of (typecode r_)))
          (IMUL a+ a+ (size-of (typecode a_)))
          (LEA *rx (ptr (typecode r_) *r n))
          'loop
          (CMP *r *rx)
          (JE 'return)
          (unary-op (project (rebase *r r_)) (project (rebase *a a_)) op)
          (ADD *r r+)
          (ADD *a a+)
          (JMP 'loop)
          'return)))

(define-method (binary-op (r_ <pointer<>>) (a_ <pointer<>>) (b_ <var>) op)
  (let [(r (make <var> #:type (typecode r_) #:symbol 'r))]
    (list ((if (eqv? (bits (typecode r_)) (bits (typecode a_)))
             MOV
             (if (signed? (typecode a_)) MOVSX MOVZX))
           r (ptr (typecode a_) (get-value a_)))
          (if (eqv? (bits (typecode r_)) (bits (typecode b_)))
            (op r b_)
            (let [(b (make <var> #:type (typecode r_)))]
              (list ((if (signed? (typecode b_)) MOVSX MOVZX) b b_)
                    (op r b))))
          (MOV (ptr (typecode r_) (get-value r_)) r))))
(define-method (binary-op (r_ <pointer<>>) (a_ <var>) (b_ <pointer<>>) op)
  (let [(r (make <var> #:type (typecode r_) #:symbol 'r))]
    (list ((if (eqv? (bits (typecode r_)) (bits (typecode a_)))
             MOV
             (if (signed? (typecode a_)) MOVSX MOVZX))
           r a_)
          (if (eqv? (bits (typecode r_)) (bits (typecode b_)))
            (op r (ptr (typecode b_) (get-value b_)))
            (let [(b (make <var> #:type (typecode r_)))]
              (list ((if (signed? (typecode b_)) MOVSX MOVZX) b (ptr (typecode b_) (get-value b_)))
                    (op r b))))
          (MOV (ptr (typecode r_) (get-value r_)) r))))
(define-method (binary-op (r_ <pointer<>>) (a_ <pointer<>>) (b_ <pointer<>>) op); TODO: fix this one
  (let [(r (make <var> #:type (typecode r_) #:symbol 'r))]
    (list ((if (eqv? (bits (typecode r_)) (bits (typecode a_)))
             MOV
             (if (signed? (typecode a_)) MOVSX MOVZX))
           r (ptr (typecode a_) (get-value a_)))
          (if (eqv? (bits (typecode r_)) (bits (typecode b_)))
            (op r (ptr (typecode b_) (get-value b_)))
            (let [(b (make <var> #:type (typecode r_)))]
              (list ((if (signed? (typecode b_)) MOVSX MOVZX) b (ptr (typecode b_) (get-value b_)))
                    (op r b))))
          (MOV (ptr (typecode r_) (get-value r_)) r))))
(define-method (binary-op (r_ <sequence<>>) (a_ <sequence<>>) (b_ <var>) op)
  (let [(*r  (make <var> #:type <long> #:symbol '*r))
        (r+  (make <var> #:type <long> #:symbol 'r+))
        (n   (make <var> #:type <long> #:symbol 'n))
        (*a  (make <var> #:type <long> #:symbol '*a))
        (a+  (make <var> #:type <long> #:symbol 'a+))
        (*rx (make <var> #:type <long> #:symbol '*rx))]
    (list (MOV *r (get-value r_))
          (MOV r+ (last (strides r_)))
          (MOV n (last (shape r_)))
          (MOV *a (get-value a_))
          (MOV a+ (last (strides a_)))
          (IMUL n r+)
          (IMUL r+ r+ (size-of (typecode r_)))
          (IMUL a+ a+ (size-of (typecode a_)))
          (LEA *rx (ptr (typecode r_) *r n))
          'loop
          (CMP *r *rx)
          (JE 'return)
          (binary-op (project (rebase *r r_)) (project (rebase *a a_)) b_ op)
          (ADD *r r+)
          (ADD *a a+)
          (JMP 'loop)
          'return)))
(define-method (binary-op (r_ <sequence<>>) (a_ <var>) (b_ <sequence<>>)  op)
  (let [(*r  (make <var> #:type <long> #:symbol '*r))
        (r+  (make <var> #:type <long> #:symbol 'r+))
        (n   (make <var> #:type <long> #:symbol 'n))
        (*b  (make <var> #:type <long> #:symbol '*b))
        (b+  (make <var> #:type <long> #:symbol 'b+))
        (*rx (make <var> #:type <long> #:symbol '*rx))]
    (list (MOV *r (get-value r_))
          (MOV r+ (last (strides r_)))
          (MOV n (last (shape r_)))
          (MOV *b (get-value b_))
          (MOV b+ (last (strides b_)))
          (IMUL n r+)
          (IMUL r+ r+ (size-of (typecode r_)))
          (IMUL b+ b+ (size-of (typecode b_)))
          (LEA *rx (ptr (typecode r_) *r n))
          'loop
          (CMP *r *rx)
          (JE 'return)
          (binary-op (project (rebase *r r_)) a_ (project (rebase *b b_)) op)
          (ADD *r r+)
          (ADD *b b+)
          (JMP 'loop)
          'return)))
(define-method (binary-op (r_ <sequence<>>) (a_ <sequence<>>)  (b_ <sequence<>>)  op)
  (let [(*r  (make <var> #:type <long> #:symbol '*r))
        (r+  (make <var> #:type <long> #:symbol 'r+))
        (n   (make <var> #:type <long> #:symbol 'n))
        (*a  (make <var> #:type <long> #:symbol '*a))
        (a+  (make <var> #:type <long> #:symbol 'a+))
        (*b  (make <var> #:type <long> #:symbol '*b))
        (b+  (make <var> #:type <long> #:symbol 'b+))
        (*rx (make <var> #:type <long> #:symbol '*rx))]
    (list (MOV *r (get-value r_))
          (MOV r+ (last (strides r_)))
          (MOV n (last (shape r_)))
          (MOV *a (get-value a_))
          (MOV a+ (last (strides a_)))
          (MOV *b (get-value b_))
          (MOV b+ (last (strides b_)))
          (IMUL n r+)
          (IMUL r+ r+ (size-of (typecode r_)))
          (IMUL a+ a+ (size-of (typecode a_)))
          (IMUL b+ b+ (size-of (typecode b_)))
          (LEA *rx (ptr (typecode r_) *r n))
          'loop
          (CMP *r *rx)
          (JE 'return)
          (binary-op (project (rebase *r r_)) (project (rebase *a a_)) (project (rebase *b b_)) op)
          (ADD *r r+)
          (ADD *a a+)
          (ADD *b b+)
          (JMP 'loop)
          'return)))

(define-syntax-rule (define-unary-op name op)
  (define-method (name (a <element>))
    (let [(fun (wrap ctx <null> (list (class-of a) (class-of a))
                 (lambda (r_ a_) (list (unary-op r_ a_ op) (RET)))))]
      (add-method! name
                   (make <method>
                         #:specializers (list (class-of a))
                         #:procedure (lambda (a)
                                       (let [(r (make (class-of a) #:shape (shape a)))]
                                         (fun r a)
                                         r)))))
    (name a)))

(define-method (shape a b)
  (let [(shape-a (shape a))
        (shape-b (shape b))]
    (if (>= (length shape-a) (length shape-b)) shape-a shape-b)))

(define-syntax-rule (define-binary-op name op)
  (begin
    (define-method (name (a <element>) (b <element>))
      (let* [(result-type (coerce (class-of a) (class-of b)))
             (fun         (wrap ctx <null>
                                (list result-type (class-of a) (class-of b))
                                (lambda (r_ a_ b_) (list (binary-op r_ a_ b_ op) (RET)))))]
        (add-method! name
                     (make <method>
                           #:specializers (list (class-of a) (class-of b))
                           #:procedure (lambda (a b)
                                         (let [(r (make (coerce (class-of a) (class-of b)) #:shape (shape a b)))]
                                           (fun r (get a) (get b))
                                           r)))))
      (name a b))
    (define-method (name (a <element>) b) (name a (make (match b) #:value b)))
    (define-method (name a (b <element>)) (name (make (match a) #:value a) b))))

(define-unary-op duplicate (const '()))
(define-unary-op - NEG)

(define-binary-op + ADD)
(define-binary-op - SUB)
(define-binary-op * IMUL)

(define (fill t n value); TODO: replace with tensor operation
  (let [(retval (make (sequence t) #:size n))]
    (store retval value)
    retval))
;(define-method (binary-op (fun <jit-function>) (r_ <element>) (a_ <element>) (b_ <element>) op)
;  (env fun
;       [(r  (reg (get-value r_) fun))
;        (a  (reg (get-value a_) fun))
;        (b  (reg (get-value b_) fun))
;        (w  (reg (class-of r_) fun))]
;       ((if (eqv? (size-of (class-of a_)) (size-of (class-of r_)))
;          MOV
;          (if (signed? (class-of a_)) MOVSX MOVZX)) r a)
;       (if (eqv? (size-of (class-of b_)) (size-of (class-of r_)))
;         (op r b)
;         (append
;           ((if (signed? (class-of b_)) MOVSX MOVZX) w b)
;           (op r w)))))
;(define-method (binary-op (fun <jit-function>) (r_ <pointer<>>) (a_ <pointer<>>) (b_ <element>) op)
;  (env fun
;       [(*r (reg (get-value r_) fun))
;        (*a (reg (get-value a_) fun))
;        (b  (reg (get-value b_) fun))
;        (r  (reg (typecode r_) fun))
;        (w  (reg (typecode r_) fun))]
;       ((if (eqv? (size-of (typecode a_)) (size-of (typecode r_)))
;          MOV
;          (if (signed? (typecode a_)) MOVSX MOVZX)) r (ptr (typecode a_) *a))
;       (if (eqv? (size-of (class-of b_)) (size-of (typecode r_)))
;         (op r b)
;         (append
;           ((if (signed? (class-of b_)) MOVSX MOVZX) w b)
;           (op r w)))
;       (MOV (ptr (typecode r_) *r) r)))
;(define-method (binary-op (fun <jit-function>) (r_ <pointer<>>) (a_ <element>) (b_ <pointer<>>) op)
;   (env fun
;       [(*r (reg (get-value r_) fun))
;        (a  (reg (get-value a_) fun))
;        (*b (reg (get-value b_) fun))
;        (r  (reg (typecode r_) fun))
;        (w  (reg (typecode r_) fun))]
;       ((if (eqv? (size-of (class-of a_)) (size-of (typecode r_)))
;          MOV
;          (if (signed? (class-of a_)) MOVSX MOVZX)) r a)
;       (if (eqv? (size-of (typecode b_)) (size-of (typecode r_)))
;         (op r (ptr (typecode b_) *b))
;         (append
;           ((if (signed? (typecode b_)) MOVSX MOVZX) w (ptr (typecode b_) *b))
;           (op r w)))
;       (MOV (ptr (typecode r_) *r) r)))
;(define-method (binary-op (fun <jit-function>) (r_ <pointer<>>) (a_ <pointer<>>) (b_ <pointer<>>) op)
;  (env fun
;       [(*r (reg (get-value r_) fun))
;        (*a (reg (get-value a_) fun))
;        (*b (reg (get-value b_) fun))
;        (r  (reg (typecode r_) fun))
;        (w  (reg (typecode r_) fun))]
;       ((if (eqv? (size-of (typecode a_)) (size-of (typecode r_)))
;          MOV
;          (if (signed? (typecode a_)) MOVSX MOVZX)) r (ptr (typecode a_) *a))
;       (if (eqv? (size-of (typecode b_)) (size-of (typecode r_)))
;         (op r (ptr (typecode b_) *b))
;         (append
;           ((if (signed? (typecode b_)) MOVSX MOVZX) w (ptr (typecode b_) *b))
;           (op r w)))
;       (MOV (ptr (typecode r_) *r) r)))
;(define-method (binary-op (fun <jit-function>) (r_ <sequence<>>) (a_ <sequence<>>) (b_ <element>) op)
;  (env fun
;       [(rs  (reg (last (strides r_)) fun))
;        (n   (reg (last (shape r_)) fun))
;        (as  (reg (last (strides a_)) fun))
;        (*r  (reg <long> fun))
;        (r+  (reg <long> fun))
;        (*a  (reg <long> fun))
;        (a+  (reg <long> fun))
;        (*rx (reg <long> fun))]
;       (IMUL n rs)
;       (MOV *r (loc (get-value r_) fun))
;       (MOV *a (loc (get-value a_) fun))
;       (LEA *rx (ptr (typecode r_) *r n))
;       (IMUL r+ rs (size-of (typecode r_)))
;       (IMUL a+ as (size-of (typecode a_)))
;       (CMP *r *rx)
;       (JE 'return)
;       'loop
;       (binary-op fun (project (rebase *r r_)) (project (rebase *a a_)) b_ op)
;       (ADD *r r+)
;       (ADD *a a+)
;       (CMP *r *rx)
;       (JNE 'loop)
;       'return))
;(define-method (binary-op (fun <jit-function>) (r_ <sequence<>>) (a_ <element>) (b_ <sequence<>>) op)
;  (env fun
;       [(rs  (reg (last (strides r_)) fun))
;        (n   (reg (last (shape r_)) fun))
;        (a   (reg (get-value a_) fun))
;        (bs  (reg (last (strides b_)) fun))
;        (*r  (reg <long> fun))
;        (r+  (reg <long> fun))
;        (*b  (reg <long> fun))
;        (b+  (reg <long> fun))
;        (*rx (reg <long> fun))]
;       (IMUL n rs)
;       (MOV *r (loc (get-value r_) fun))
;       (MOV *b (loc (get-value b_) fun))
;       (LEA *rx (ptr (typecode r_) *r n))
;       (IMUL r+ rs (size-of (typecode r_)))
;       (IMUL b+ bs (size-of (typecode b_)))
;       (CMP *r *rx)
;       (JE 'return)
;       'loop
;       (binary-op fun (project (rebase *r r_)) a_ (project (rebase *b b_)) op)
;       (ADD *r r+)
;       (ADD *b b+)
;       (CMP *r *rx)
;       (JNE 'loop)
;       'return))
;(define-method (binary-op (fun <jit-function>) (r_ <sequence<>>) (a_ <sequence<>>) (b_ <sequence<>>) op)
;  (env fun
;       [(r+  (reg (last (strides r_)) fun))
;        (a+  (reg (last (strides a_)) fun))
;        (b+  (reg (last (strides b_)) fun))
;        (n   (reg (last (shape r_)) fun))
;        (*r  (reg <long> fun))
;        (*a  (reg <long> fun))
;        (*b  (reg <long> fun))
;        (*rx (reg <long> fun))]
;       (IMUL n r+)
;       (MOV *r (loc (get-value r_) fun))
;       (MOV *a (loc (get-value a_) fun))
;       (MOV *b (loc (get-value b_) fun))
;       (LEA *rx (ptr (typecode r_) *r n))
;       (IMUL r+ r+ (size-of (typecode r_))); TODO: multiply r+ multiple times!
;       (IMUL a+ a+ (size-of (typecode a_)))
;       (IMUL b+ b+ (size-of (typecode b_)))
;       (CMP *r *rx)
;       (JE 'return)
;       'loop
;       (binary-op fun (project (rebase *r r_)) (project (rebase *a a_)) (project (rebase *b b_)) op)
;       (ADD *r r+)
;       (ADD *a a+)
;       (ADD *b b+)
;       (CMP *r *rx)
;       (JNE 'loop)
;       'return))

