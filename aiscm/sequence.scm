(define-module (aiscm sequence)
  #:use-module (oop goops)
  #:use-module (ice-9 optargs)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-26)
  #:use-module (aiscm element)
  #:use-module (aiscm util)
  #:use-module (aiscm mem)
  #:use-module (aiscm pointer)
  #:export (<meta<sequence<>>> <sequence<>>
            sequence multiarray multiarray->list list->multiarray strides
            drop crop roll unroll downsample))
(define-generic element-type)
(define-class <meta<sequence<>>> (<meta<element>>))
(define-class <sequence<>> (<element>)
              (shape #:init-keyword #:shape #:getter shape)
              (strides #:init-keyword #:strides #:getter strides)
              #:metaclass <meta<sequence<>>>)
(define-method (sequence-name (type <meta<element>>))
  (format #f "<sequence~a>" (class-name type)))
(define-method (sequence-name (type <meta<sequence<>>>))
  (format #f "<multiarray~a,~a>" (class-name (typecode type)) (1+ (dimension type))))
(define (default-strides shape)
  (map (compose (cut apply * <>) (cut take shape <>)) (upto 0 (1- (length shape)))))
(define (sequence type)
  (let* [(name      (sequence-name type))
         (metaname  (format #f "<meta~a>" name))
         (metaclass (def-once metaname (make <class>
                                             #:dsupers (list <meta<sequence<>>>)
                                             #:name metaname)))
         (retval    (def-once name (make metaclass
                                         #:dsupers (list <sequence<>>)
                                         #:name name)))]
    (define-method (initialize (self retval) initargs)
      (let-keywords initargs #f (shape size value strides)
        (let* [(value   (or value (make <mem>
                                   #:size (* (size-of (typecode type))
                                             (or size (apply * shape))))))
               (shape   (or shape (list size)))
               (strides (or strides (default-strides shape)))]
          (next-method self (list #:value value #:shape shape #:strides strides)))))
    (define-method (element-type (self metaclass)) (pointer type))
    (define-method (dimension (self metaclass)) (1+ (dimension type)))
    (define-method (typecode (self metaclass)) (typecode type))
    retval))
(define-method (pointer (target-class <meta<sequence<>>>)) target-class)
(define (multiarray type dimension)
  (if (zero? dimension) (pointer type) (multiarray (sequence type) (1- dimension))))
(define-method (size (self <sequence<>>)) (apply * (shape self)))
(define (element offset self)
  (make (element-type (class-of self))
        #:value   (+ (get-value self) (* offset (last (strides self)) (size-of (typecode self))))
        #:shape   (all-but-last (shape self))
        #:strides (all-but-last (strides self))))
(define-method (crop (n <integer>) (self <sequence<>>))
  (make (class-of self)
        #:value   (get-value self)
        #:shape   (append (all-but-last (shape self)) (list n))
        #:strides (strides self)))
(define-method (crop (n <null>) (self <sequence<>>)) self)
(define-method (crop (n <pair>) (self <sequence<>>))
  (crop (last n) (unroll (crop (all-but-last n) (roll self)))))
(define-method (drop (offset <integer>) (self <sequence<>>))
  (make (class-of self)
        #:value   (+ (get-value self) (* offset (last (strides self)) (size-of (typecode self))))
        #:shape   (append (all-but-last (shape self)) (list (- (last (shape self)) offset)))
        #:strides (strides self)))
(define-method (drop (n <null>) (self <sequence<>>)) self)
(define-method (drop (n <pair>) (self <sequence<>>))
  (drop (last n) (unroll (drop (all-but-last n) (roll self)))))
(define-method (fetch (self <sequence<>>)) self)
(define-method (get (self <sequence<>>) . args)
  (if (null? args) self (get (fetch (fold-right element self args)))))
(define-method (set (self <sequence<>>) . args)
  (store (fold-right element self (all-but-last args)) (last args)))
(define-method (store (self <sequence<>>) value)
  (for-each (compose (cut store <> value) (cut element <> self))
            (upto 0 (1- (last (shape self)))))
  value)
(define-method (store (self <sequence<>>) (value <null>)) value)
(define-method (store (self <sequence<>>) (value <pair>))
  (store (element 0 self) (car value))
  (store (drop 1 self) (cdr value))
  value)
(define-method (multiarray->list self) self)
(define-method (multiarray->list (self <sequence<>>))
  (map (compose multiarray->list (cut get self <>)) (upto 0 (1- (last (shape self))))))
(define-method (shape (self <null>)) #f)
(define-method (shape (self <pair>)) (append (shape (car self)) (list (length self))))
(define (list->multiarray lst)
  (let* [(type   (reduce coerce #f (map match (flatten lst))))
         (shape  (shape lst))
         (retval (make (multiarray type (length shape)) #:shape shape))]
    (store retval lst)
    retval))
(define-method (write (self <sequence<>>) port)
  (format port "#~a:~&~a" (class-name (class-of self)) (multiarray->list self)))
(define-method (display (self <sequence<>>) port)
  (format port "#~a:~&~a" (class-name (class-of self)) (multiarray->list self)))
(define-method (coerce (a <meta<sequence<>>>) (b <meta<element>>))
  (sequence (coerce (typecode a) b)))
(define-method (coerce (a <meta<element>>) (b <meta<sequence<>>>))
  (sequence (coerce a (typecode b))))
(define-method (coerce (a <meta<sequence<>>>) (b <meta<sequence<>>>))
  (sequence (coerce (typecode a) (typecode b))))
(define (roll self) (make (class-of self)
        #:value   (get-value self)
        #:shape   (cycle (shape self))
        #:strides (cycle (strides self))))
(define (unroll self) (make (class-of self)
        #:value   (get-value self)
        #:shape   (uncycle (shape self))
        #:strides (uncycle (strides self))))
(define-method (downsample (n <integer>) (self <sequence<>>))
   (let [(shape   (shape self))
         (strides (strides self))]
     (make (class-of self)
           #:value   (get-value self)
           #:shape   (append (all-but-last shape) (list (quotient (+ (1- n) (last shape)) n)))
           #:strides (append (all-but-last strides) (list (* n (last strides)))))))
(define-method (downsample (n <null>) (self <sequence<>>)) self)
(define-method (downsample (n <pair>) (self <sequence<>>))
  (downsample (last n) (unroll (downsample (all-but-last n) (roll self)))))
