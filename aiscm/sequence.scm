(define-module (aiscm sequence)
  #:use-module (oop goops)
  #:use-module (ice-9 optargs)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-26)
  #:use-module (aiscm element)
  #:use-module (aiscm util)
  #:use-module (aiscm mem)
  #:use-module (aiscm pointer)
  #:export (<meta<sequence<>>> <sequence<>>
            sequence
            multiarray
            strides
            sequence->list
            list->sequence))
(define-generic element-type)
(define-class <meta<sequence<>>> (<meta<element>>))
(define-class <sequence<>> (<element>)
              (shape #:init-keyword #:shape #:getter shape)
              (strides #:init-keyword #:strides #:getter strides)
              #:metaclass <meta<sequence<>>>)
(define-method (sequence-name (type <meta<element>>))
  (format #f "<sequence~a>" (class-name type)))
(define-method (sequence-name (type <meta<sequence<>>>))
  (format #f "<multiarray~a,~a>" (class-name (typecode type)) (1+ (dimension type))))
(define (default-strides shape)
  (map (compose (cut apply * <>) (cut take shape <>)) (upto 0 (1- (length shape)))))
(define (sequence type)
  (let* [(name      (sequence-name type))
         (metaname  (format #f "<meta~a>" name))
         (metaclass (def-once metaname (make <class>
                                             #:dsupers (list <meta<sequence<>>>)
                                             #:slots '()
                                             #:name metaname)))
         (retval    (def-once name (make metaclass
                                         #:dsupers (list <sequence<>>)
                                         #:slots '()
                                         #:name name)))]
    (define-method (initialize (self retval) initargs)
      (let-keywords initargs #f (shape size value)
        (let* [(n   (or size (apply * shape)))
               (mem (make <mem> #:size (* (size-of (typecode type)) n)))
               (val (or value (make (pointer type) #:value mem)))
               (shp (or shape (list size)))
               (str (default-strides shp))]
          (next-method self `(#:value ,val #:shape ,shp #:strides ,str)))))
    (define-method (element-type (self metaclass)) type)
    (define-method (dimension (self metaclass)) (1+ (dimension type)))
    (define-method (typecode (self metaclass)) (typecode type))
    retval))
(define (multiarray type dimension)
  (if (> dimension 0) (sequence (multiarray type (1- dimension))) type))
(define-method (size (self <sequence<>>)) (apply * (shape self)))
(define-method (set (self <sequence<>>) (i <integer>) o)
  (begin (store (+ (get-value self) i) (make (typecode self) #:value o)) o))
(define-method (set (self <sequence<>>) o)
  (if (> (count self) 0)
    (begin (set self 0 (car o))
           (set (slice self 1 (1- (count self))) (cdr o))
           o)
    o))
(define (count self) (car (shape self)))
(define-method (get (self <sequence<>>) (i <integer>))
  (get-value (fetch (+ (get-value self) i))))
(define-method (slice (self <sequence<>>) (offset <integer>) (size <integer>))
  (make (class-of self) #:value (+ (get-value self) offset) #:shape (cons size (cdr (shape self)))))
(define (sequence->list seq)
  (if (> (count seq) 0)
    (cons (get seq 0) (sequence->list (slice seq 1 (- (count seq) 1)))) '()))
(define-method (shape (self <null>)) #f)
(define-method (shape (self <pair>)) (append (shape (car self)) (list (length self))))
(define (list->sequence lst)
  (let* [(t      (reduce coerce '() (map match lst)))
         (retval (make (sequence t) #:size (length lst)))]
    (set retval lst)
    retval))
(define-method (write (self <sequence<>>) port)
  (format port "#~a:~&~a" (class-name (class-of self)) (sequence->list self)))
(define-method (display (self <sequence<>>) port)
  (format port "#~a:~&~a" (class-name (class-of self)) (sequence->list self)))
(define-method (coerce (a <meta<sequence<>>>) (b <meta<element>>))
  (sequence (coerce (typecode a) b)))
(define-method (coerce (a <meta<element>>) (b <meta<sequence<>>>))
  (sequence (coerce a (typecode b))))
(define-method (coerce (a <meta<sequence<>>>) (b <meta<sequence<>>>))
  (sequence (coerce (typecode a) (typecode b))))
