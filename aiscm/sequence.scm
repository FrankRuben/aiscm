(define-module (aiscm sequence)
  #:use-module (oop goops)
  #:use-module (ice-9 optargs)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-26)
  #:use-module (aiscm element)
  #:use-module (aiscm util)
  #:use-module (aiscm mem)
  #:use-module (aiscm pointer)
  #:export (<meta<sequence<>>> <sequence<>>
            sequence
            multiarray
            element
            sequence->list
            list->sequence))
(define-generic element-type)
(define-class <meta<sequence<>>> (<meta<element>>))
(define-class <sequence<>> (<element>)
              (shape #:init-keyword #:shape #:getter shape)
              (strides #:init-keyword #:strides #:getter strides)
              #:metaclass <meta<sequence<>>>)
(define-method (sequence-name (type <meta<element>>))
  (format #f "<sequence~a>" (class-name type)))
(define-method (sequence-name (type <meta<sequence<>>>))
  (format #f "<multiarray~a,~a>" (class-name (typecode type)) (1+ (dimension type))))
(define (default-strides shape)
  (map (compose (cut apply * <>) (cut take shape <>)) (upto 0 (1- (length shape)))))
(define (sequence type)
  (let* [(name      (sequence-name type))
         (metaname  (format #f "<meta~a>" name))
         (metaclass (def-once metaname (make <class>
                                             #:dsupers (list <meta<sequence<>>>)
                                             #:slots '()
                                             #:name metaname)))
         (retval    (def-once name (make metaclass
                                         #:dsupers (list <sequence<>>)
                                         #:slots '()
                                         #:name name)))]
    (define-method (initialize (self retval) initargs)
      (let-keywords initargs #f (shape size value strides)
        (let* [(n   (or size (apply * shape)))
               (t   (typecode type))
               (mem (make <mem> #:size (* (size-of t) n)))
               (val (or value (make (pointer t) #:value mem)))
               (shp (or shape (list size)))
               (str (or strides (default-strides shp)))]
          (next-method self `(#:value ,val #:shape ,shp #:strides ,str)))))
    (define-method (element-type (self metaclass)) type)
    (define-method (dimension (self metaclass)) (1+ (dimension type)))
    (define-method (typecode (self metaclass)) (typecode type))
    retval))
(define-method (pointer (target-class <meta<sequence<>>>)) target-class)
(define (multiarray type dimension)
  (if (zero? dimension) (pointer type) (multiarray (sequence type) (1- dimension))))
(define (num-elements self) (car (shape self)))
(define-method (size (self <sequence<>>)) (apply * (shape self)))
(define-method (set (self <sequence<>>) (i <integer>) o)
  (begin (store (+ (get-value self) i) (make (typecode self) #:value o)) o))
(define-method (set (self <sequence<>>) o)
  (if (> (num-elements self) 0)
    (begin (set self 0 (car o))
           (set (slice self 1 (1- (num-elements self))) (cdr o))
           o)
    o))
;(define (element self idx)
;  (make (pointer (element-type (class-of self)))
;        #:value (+ (get-value self) (* idx (last (strides self))))
;        #:shape (all-but-last (shape self))
;        #:strides (all-but-last (strides self))))
(define-method (get (self <sequence<>>) . args)
  (if (null? args)
    self
    (let [(retval (if (not (zero? (dimension (element-type (class-of self)))))
                    (make (element-type (class-of self))
                          #:value   (+ (get-value self) (* (last args) (last (strides self))))
                          #:shape   (all-but-last (shape self))
                          #:strides (all-but-last (strides self)))
                    (fetch (+ (get-value self) (* (last args) (last (strides self)))))))]
      (apply get (cons retval (all-but-last args))))))
(define-method (slice (self <sequence<>>) (offset <integer>) (size <integer>))
  (make (class-of self) #:value (+ (get-value self) offset) #:shape (cons size (cdr (shape self)))))
(define-method (sequence->list self) self)
(define-method (sequence->list (self <sequence<>>))
  (map (compose sequence->list (cut get self <>)) (upto 0 (1- (last (shape self))))))
(define-method (shape (self <null>)) #f)
(define-method (shape (self <pair>)) (append (shape (car self)) (list (length self))))
(define (list->sequence lst)
  (let* [(t      (reduce coerce '() (map match lst)))
         (retval (make (sequence t) #:size (length lst)))]
    (set retval lst)
    retval))
(define-method (write (self <sequence<>>) port)
  (format port "#~a:~&~a" (class-name (class-of self)) (sequence->list self)))
(define-method (display (self <sequence<>>) port)
  (format port "#~a:~&~a" (class-name (class-of self)) (sequence->list self)))
(define-method (coerce (a <meta<sequence<>>>) (b <meta<element>>))
  (sequence (coerce (typecode a) b)))
(define-method (coerce (a <meta<element>>) (b <meta<sequence<>>>))
  (sequence (coerce a (typecode b))))
(define-method (coerce (a <meta<sequence<>>>) (b <meta<sequence<>>>))
  (sequence (coerce (typecode a) (typecode b))))
