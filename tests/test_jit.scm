(use-modules (oop goops)
             (rnrs bytevectors)
             (srfi srfi-1)
             (srfi srfi-26)
             (aiscm util)
             (aiscm asm)
             (aiscm mem)
             (aiscm jit)
             (aiscm element)
             (aiscm int)
             (aiscm pointer)
             (aiscm sequence)
             (aiscm bool)
             (aiscm rgb)
             (aiscm complex)
             (guile-tap))
(planned-tests 352)
(define ctx (make <context>))
(define b1 (random (ash 1  6)))
(define b2 (random (ash 1  6)))
(define w1 (random (ash 1 14)))
(define w2 (random (ash 1 14)))
(define i1 (random (ash 1 30)))
(define i2 (random (ash 1 30)))
(define l1 (random (ash 1 62)))
(define l2 (random (ash 1 62)))
(define mem (make <mem> #:size 256))
(define bptr (make (pointer <byte>) #:value mem))
(define wptr (make (pointer <sint>) #:value mem))
(define iptr (make (pointer <int>) #:value mem))
(define lptr (make (pointer <long>) #:value mem))
(define (bdata) (begin
                  (store bptr       b1)
                  (store (+ bptr 1) b2)
                  mem))
(define (wdata) (begin
                  (store wptr       w1)
                  (store (+ wptr 1) w2)
                  mem))
(define (idata) (begin
                  (store iptr       i1)
                  (store (+ iptr 1) i2)
                  mem))
(define (ldata) (begin
                  (store lptr       l1)
                  (store (+ lptr 1) l2)
                  mem))
(let [(a (var <int>))
      (b (var <int>))]
  (ok (equal? (list b) (input (MOV a b)))
      "Get input variables of MOV")
  (ok (equal? (list a b) (input (ADD a b)))
      "Get input variables of ADD")
  (ok (equal? (list a) (input (ADD a a)))
      "Prevent duplication of input variables")
  (ok (equal? (list a) (output (MOV a b)))
      "Get output variables of MOV")
  (ok (equal? (list a) (output (ADD a b)))
      "Get output variables of ADD")
  (ok (equal? (list b a) (input (MOV (ptr <int> a) b)))
    "Get input variables of command writing to address")
  (ok (equal? (list a 0) (get-args (MOV a 0)))
      "Get arguments of command")
  (ok (equal?  (list a b) (variables (list (MOV a 0) (MOV b a))))
      "Get variables of a program")
  (let [(p (var <long>))]
    (ok (equal?  (list a p) (variables (list (MOV a 0) (MOV (ptr <int> p) a))))
        "Get variables of a program using a pointer"))
  (ok (equal? (list (MOV ECX 42)) (substitute-variables (list (MOV a 42)) (list (cons a RCX))))
      "Substitute integer variable with register")
  (ok (equal? (MOV EAX 0)
              (substitute-variables (substitute-variables (MOV a 0) (list (cons a b))) (list (cons b RAX))))
      "Substitute variable with another")
  (ok (equal? (MOV ECX EDX) (substitute-variables (MOV a b) (list (cons a RCX) (cons b RDX))))
      "Substitution works with 'MOV'")
  (let [(p (var <long>))]
    (ok (equal? (list (MOV RCX (ptr <long> RAX)))
                (substitute-variables (list (MOV p (ptr <long> RAX))) (list (cons p RCX))))
        "Substitute long integer variable with register")
    (ok (equal? (list (MOV (ptr <int> RCX) ESI))
                (substitute-variables (list (MOV (ptr <int> p) a)) (list (cons p RCX) (cons a RSI))))
        "Substitute pointer variable"))
  (let [(l (var <long>))
        (w (var <sint>))]
    (ok (equal? (MOVSX RCX EDX) (substitute-variables (MOVSX l a) (list (cons l RCX) (cons a RDX))))
        "Substitution works with 'MOVSX'")
    (ok (equal? (MOVZX ECX DX) (substitute-variables (MOVZX a w) (list (cons a RCX) (cons w RDX))))
        "Substitution works with 'MOVZX'"))
  (let [(p (var <long>))
        (q (var <long>))]
    (ok (equal? (LEA RCX (ptr <byte> RDX))
                (substitute-variables (LEA p (ptr <byte> q)) (list (cons p RCX) (cons q RDX))))
        "Substitution works with 'LEA"))
  (ok (equal? (SHL ECX) (substitute-variables (SHL a) (list (cons a RCX))))
      "Substitution works with 'SHL")
  (ok (equal? (SHR ECX) (substitute-variables (SHR a) (list (cons a RCX))))
      "Substitution works with 'SHR")
  (ok (equal? (SAL ECX) (substitute-variables (SAL a) (list (cons a RCX))))
      "Substitution works with 'SAL")
  (ok (equal? (SAR ECX) (substitute-variables (SAR a) (list (cons a RCX))))
      "Substitution works with 'SAR")
  (ok (equal? (ADD ECX EDX) (substitute-variables (ADD a b) (list (cons a RCX) (cons b RDX))))
      "Substitution works with 'ADD'")
  (ok (equal? (PUSH ECX) (substitute-variables (PUSH a) (list (cons a RCX))))
      "Substitution works with 'PUSH'")
  (ok (equal? (POP ECX) (substitute-variables (POP a) (list (cons a RCX))))
      "Substitution works with 'POP'")
  (ok (equal? (NEG ECX) (substitute-variables (NEG a) (list (cons a RCX))))
      "Substitution works with 'NEG'")
  (ok (equal? (SUB ECX EDX) (substitute-variables (SUB a b) (list (cons a RCX) (cons b RDX))))
      "Substitution works with 'SUB'")
  (ok (equal? (IMUL ECX EDX) (substitute-variables (IMUL a b) (list (cons a RCX) (cons b RDX))))
      "Substitution works with 'IMUL'")
  (ok (equal? (IMUL ECX EDX 2) (substitute-variables (IMUL a b 2) (list (cons a RCX) (cons b RDX))))
      "Substitution works with 'IMUL' and three arguments")
  (ok (equal? (CMP ECX EDX) (substitute-variables (CMP a b) (list (cons a RCX) (cons b RDX))))
      "Substitution works with 'CMP'")
  (let [(u (var <ubyte>))]
    (ok (equal? (SETB CL) (substitute-variables (SETB u) (list (cons u RCX))))
        "Substitution works with 'SETB'"))
  (ok (equal? '((a . 1) (b . 3)) (labels (list (JMP 'a) 'a (MOV AX 0) 'b (RET))))
      "'labels' should extract indices of labels"))
(ok (equal? (MOV AX CX) (mov-signed AX CX))
    "copy signed 16-bit value")
(ok (equal? (MOVSX EAX CX) (mov-signed EAX CX))
    "copy with sign extension")
(ok (equal? (MOV CL SIL) (mov-signed CL ESI))
    "copy part of signed value")
(ok (equal? (MOV AX CX) (mov-unsigned AX CX))
    "copy unsigned 16-bit value")
(ok (equal? (MOVZX EAX CX) (mov-unsigned EAX CX))
    "copy with zero extension")
(ok (equal? (MOV CL SIL) (mov-unsigned CL ESI))
    "copy part of unsigned value")
(ok (equal? (MOV RAX RCX) (mov-unsigned RAX ECX)); TODO: map to MOV EAX ECX
    "zero-extending 32-bit value is done by default")
(ok (equal? '(1) (next-indices (MOV CX 0) 0 '()))
    "Get following indices for first statement in a program")
(ok (equal? '(2) (next-indices (MOV AX CX) 1 '()))
    "Get following indices for second statement in a program")
(ok (equal? '() (next-indices (RET) 2 '()))
    "RET statement should not have any following indices")
(ok (equal? '(2) (next-indices (JMP 'a) 0 '((a . 2))))
    "Get following indices for a jump statement")
(ok (equal? '(1 2) (next-indices (JNE 'a) 0 '((a . 2))))
    "Get following indices for a conditional jump")
(let [(a (var <int>))
      (b (var <int>))
      (c (var <int>))]
  (ok (equal? (list '() (list a) '()) (live-analysis (list 'x (MOV a 0) (RET))))
      "Live-analysis for definition of unused variable")
  (ok (equal? (list (list a) (list a) (list b a) '()) (live-analysis (list (MOV a 0) (NOP) (MOV b a) (RET))))
      "Live-analysis for definition and later use of a variable")
  (ok (equal? (list (list a) (list a) (list a) (list a) '())
              (live-analysis (list (MOV a 0) 'x (ADD a 1) (JE 'x) (RET))))
      "Live-analysis with conditional jump statement")
  (ok (equal? (list (MOV EAX 42) (RET)) (register-allocate (list (MOV a 42) (RET))))
      "Allocate a single register")
  (ok (equal? (list (MOV ECX 42) (RET))
              (register-allocate (list (MOV a 42) (RET)) #:registers (list RCX RDX)))
      "Allocate a single register using custom list of registers")
  (ok (equal? (list (MOV ECX 1) (MOV EAX 2) (ADD ECX EAX) (MOV EAX ECX) (RET))
              (register-allocate (list (MOV a 1) (MOV b 2) (ADD a b) (MOV c a) (RET))))
      "Allocate multiple registers")
  (ok (equal? (list (MOV ECX 1) (ADD ECX ESI) (MOV EAX ECX) (RET))
              (register-allocate (list (MOV b 1) (ADD b a) (MOV c b) (RET))
                                 #:predefined (list (cons a RSI) (cons c RAX))))
      "Register allocation with predefined registers")
  (ok (equal? (list (MOV EAX EDI) (ADD EAX ESI) (RET))
              (virtual-variables (list a) (list b c) (list (MOV a b) (ADD a c) (RET))))
      "'virtual-variables' uses the specified variables as parameters")
  (ok (equal? (list (MOV ECX EDI) (MOV EAX ECX) (RET))
              (virtual-variables (list a) (list b) (list (MOV c b) (MOV a c) (RET))))
      "'virtual-variables' allocates local variables"))
(ok (eq? 'new (get-target (retarget (JMP 'old) 'new)))
    "'retarget' should update target of jump statement")
(ok (equal? (list (JMP 1) 'a (NOP) (RET))
            (flatten-code (list (list (JMP 1) 'a) (NOP) (RET))))
    "'flatten-code' should flatten nested environments")
(let [(a (var <int>))
      (b (var <int>))]
  (ok (equal? (list (MOV EAX EDI) (RET))
              (virtual-variables (list a) (list b) (list (list (MOV a b)) (RET))))
      "'pass-parameter-variables' handles nested code blocks")
  (ok (equal? (list (MOV ECX (ptr <int> RSP 8)) (MOV EAX ECX) (RET))
              (let [(args (map var (make-list 7 <int>)))]
                 (virtual-variables (list a) args (list (MOV a (last args)) (RET)))))
      "'virtual-variables' maps the 7th integer parameter correctly"))
(ok (equal? (resolve-jumps (list (JMP 'b) (JMP 'a) 'a (NOP) 'b))
            (resolve-jumps (flatten-code (relabel (list (JMP 'a) (list (JMP 'a) 'a) (NOP) 'a)))))
    "'relabel' should create separate namespaces for labels")
(ok (lset= eq? (list RBP R12) (callee-saved (list RAX RBP R10 R10 R12 R12)))
    "'callee-saved' should extract the set of callee-saved registers")
(ok (equal? (list (MOV (ptr <long> RSP #x-8) RBP) (MOV (ptr <long> RSP #x-10) R12))
            (save-registers (list RBP R12) #x-8))
    "'save-registers' should generate instructions for saving registers on the stack")
(ok (equal? (list (MOV (ptr <long> RSP #x-10) RBP) (MOV (ptr <long> RSP #x-18) R12))
            (save-registers (list RBP R12) #x-10))
    "'save-registers' should use the specified offset")
(ok (equal? (list (MOV RBP (ptr <long> RSP #x-8)) (MOV R12 (ptr <long> RSP #x-10)))
            (load-registers (list RBP R12) #x-8))
    "'load-registers' should generate instructions for saving registers on the stack")
(ok (equal? (list (MOV RBP (ptr <long> RSP #x-10)) (MOV R12 (ptr <long> RSP #x-18)))
            (load-registers (list RBP R12) #x-10))
    "'load-registers' should use the specified offset")
(let [(a (var <int>))]
  (ok (equal? (list (MOV (ptr <long> RSP #x-8) R12) (MOV R12D 0) (MOV R12 (ptr <long> RSP #x-8)) (RET))
              (save-and-use-registers (list (MOV a 0) (RET)) (list (cons a R12)) '() -8))
      "'save-and-use-registers' should save and restore callee-saved registers")
  (ok (equal? (list (MOV (ptr <long> RSP #x-10) R12) (MOV R12D 0) (MOV R12 (ptr <long> RSP #x-10)) (RET))
              (save-and-use-registers (list (MOV a 0) (RET)) (list (cons a R12)) '() -16))
      "'save-and-use-registers' should use the specified offset for saving callee-saved registers")
  (ok (eqv? 3 ((asm ctx <int> '()
                    (virtual-variables (list a) '()
                                       (list (MOV a 0) (JMP 'a) (list 'a (MOV a 2)) 'a (ADD a 3) (RET)))) ))
      "'virtual-variables' creates separate namespaces for labels")
  (ok (equal? (list (MOV EAX 42) 'x (RET))
              (flatten-code (spill-variable a (ptr <int> RSP -8) (list (MOV EAX 42) 'x (RET)))))
      "Variable spilling ignores machine code and labels")
  (ok (equal? (list (MOV EAX 0) (MOV (ptr <int> RSP -8) EAX) (RET))
              (register-allocate (flatten-code (spill-variable a (ptr <int> RSP -8) (list (MOV a 0) (RET))))))
      "Write spilled variable to stack")
  (ok (equal? (list (MOV EAX (ptr <int> RSP -16)) (MOV ECX EAX) (RET))
              (register-allocate (flatten-code (spill-variable a (ptr <int> RSP -16) (list (MOV ECX a) (RET))))))
      "Read spilled variable from stack"))
(let [(u (var <ubyte>))]
  (ok (equal? (list (MOV AL (ptr <byte> RSP -24)) (ADD AL 1) (MOV (ptr <byte> RSP -24) AL) (RET))
              (register-allocate (flatten-code (spill-variable u (ptr <int> RSP -24) (list (ADD u 1) (RET))))))
      "Read and write spilled variable"))
(let [(a (var <int>))
      (b (var <int>))]
  (let  [(p (var <long>))]
    (ok (equal? (let [(prog (list (ADD a b) (ADD a (ptr <int> p)) (RET)))
                      (live (list (list a b p) (list a p) '()))]
                  (map (idle-live prog live) (list a b p)))
                '(0 0 1))
        "Count times a variable is live but not used"))
  (ok (equal? (list (MOV EDI 1) (MOV ESI 2) (ADD ESI 3) (ADD EDI 4) (RET))
              (register-allocate (list (MOV a 1) (MOV b 2) (ADD b 3) (ADD a 4) (RET))
                                 #:registers (list RSI RDI)))
      "'register-allocate' should use the specified set of registers")
  (ok (equal? (list (MOV ESI 1)
                    (MOV (ptr <int> RSP -8) ESI)
                    (MOV ESI 2)
                    (ADD ESI 3)
                    (MOV ESI (ptr <int> RSP -8))
                    (ADD ESI 4)
                    (MOV (ptr <int> RSP -8) ESI)
                    (RET))
              (register-allocate (list (MOV a 1) (MOV b 2) (ADD b 3) (ADD a 4) (RET))
                                 #:registers (list RSI)))
      "'register-allocate' should spill variables")
  (let  [(c (var <int>))]
    (ok (equal? (list (MOV ESI 1)
                      (MOV (ptr <int> RSP -8) ESI)
                      (MOV ESI 2)
                      (MOV (ptr <int> RSP -16) ESI)
                      (MOV ESI 3)
                      (ADD ESI 4)
                      (MOV ESI (ptr <int> RSP -16))
                      (ADD ESI 5)
                      (MOV (ptr <int> RSP -16) ESI)
                      (MOV ESI (ptr <int> RSP -8))
                      (ADD ESI 6)
                      (MOV (ptr <int> RSP -8) ESI)
                      (RET))
                (register-allocate (list (MOV a 1) (MOV b 2) (MOV c 3) (ADD c 4) (ADD b 5) (ADD a 6) (RET))
                                   #:registers (list RSI)))
        "'register-allocate' should assign separate stack locations"))
  (ok (equal? (list (MOV (ptr <long> RSP -16) RBX)
                    (MOV EBX 1)
                    (MOV (ptr <int> RSP -8) EBX)
                    (MOV EBX 2)
                    (ADD EBX 3)
                    (MOV EBX (ptr <int> RSP -8))
                    (ADD EBX 4)
                    (MOV (ptr <int> RSP -8) EBX)
                    (MOV RBX (ptr <long> RSP -16))
                    (RET))
              (register-allocate (list (MOV a 1) (MOV b 2) (ADD b 3) (ADD a 4) (RET))
                                 #:registers (list RBX)))
      "'register-allocate' should save callee-saved registers"))
(let [(a (var <int>))]
  (ok (equal? '() ((spill-parameters (list a)) (list (cons a RDI))))
      "Register-parameter does not need spilling if a register is available for it")
  (ok (equal? (list (MOV (ptr <int> RSP -16) EDI))
              ((spill-parameters (list a)) (list (cons a (ptr <int> RSP -16)))))
      "Write spilled parameter to the stack")
  (ok (equal? '() ((fetch-parameters (list a)) (list (cons a (ptr <int> RSP +8)))))
      "Stack-parameter does not need loading if it is spilled")
  (ok (equal? (list (MOV R10D (ptr <int> RSP 8)))
              ((fetch-parameters (list a)) (list (cons a R10))))
      "Read prespilled parameters into register if a register is available for it")
  (let [(b (var <int>))
        (c (var <int>))]
    (ok (equal? (list (MOV (ptr <int> RSP -8) ESI) (MOV ESI EDI) (MOV EDI (ptr <int> RSP -8)) (ADD ESI EDI) (RET))
                (virtual-variables '() (list a b) (list (MOV c a) (ADD c b) (RET)) #:registers (list RSI RDI)))
        "Spill register-parameter to the stack")
    (ok (equal? (list (MOV EDX 0) (MOV ECX 0) (CMP ECX EAX) (JE #x6) (INC ECX) (INC EDX) (JMP #x-a) (RET))
                (resolve-jumps (register-allocate (flatten-code (list (MOV a 0) (repeat b (INC a)) (RET))))))
        "'repeat' loop")))
(ok (equal? (list (MOV ECX 2) (RET)) (get-code (blocked AL (MOV ECX 2) (RET))))
    "'blocked' represents the specified code segment")
(ok (equal? RAX (get-reg (blocked RAX (MOV ECX 2) (RET))))
    "'blocked' stores the register to be blocked")
(ok (equal? (list (MOV ECX 2) (RET)) (filter-blocks (blocked RAX (MOV ECX 2) (RET))))
    "'filter-blocks' should remove blocked-register information")
(ok (equal? (list (MOV EDX 2) 'x (list (RET)))
            (filter-blocks (blocked RDX (MOV EDX 2) 'x (blocked RAX (RET)))))
    "'filter-blocks' should work recursively")
(ok (equal? (list (cons RAX '(0 . 1))) (blocked-intervals (blocked RAX (MOV EAX 0) (RET))))
    "'blocked-intervals' should extract the blocked intervals for each register")
(ok (equal? (list (cons RAX '(1 . 1))) (blocked-intervals (list (MOV EAX 0) (blocked RAX (RET)))))
    "Blocked intervals within a program should be offset correctly")
(ok (equal? (list (cons RAX '(2 . 2))) (blocked-intervals (list (list (MOV EAX 0) (NOP)) (blocked RAX (RET)))))
    "The offsets of 'blocked-intervals' should refer to the flattened code")
(ok (equal? (list (cons RAX '(1 . 4)) (cons RDX '(2 . 3)))
            (blocked-intervals (list 'x (blocked RAX (MOV AX 0) (blocked RDX (MOV DX 0) (IDIV CX)) (RET)))))
    "'blocked-intervals' should work recursively")
(let  [(w (var <usint>))]
  (ok (equal? (list (MOV AX 0) (RET))
              (virtual-variables '() '() (list (blocked RCX (MOV w 0)) (RET))))
      "'virtual-variables' filters out the reserved-registers information")
  (ok (equal? (list (MOV CX 0) (RET))
              (virtual-variables '() '() (list (blocked RAX (MOV w 0)) (RET))))
      "'virtual-variables' avoids blocked registers when allocating variables"))
(let [(a (var <int>))
      (u (var <ubyte>))]
  (ok (equal? (list (MOV CL AL) (MOV EAX (ptr <int> RSP -8)) (SHL EAX CL) (MOV (ptr <int> RSP -8) EAX) (RET))
              (spill-blocked-predefines (list (MOV CL u) (SHL a CL) (RET))
                                        #:predefined (list (cons a RCX))
                                        #:blocked (list (cons RCX '(0 . 1)))))
      "Spill predefined registers if they are blocked"))
(ok (equal? (list SIL AX R9D RDX) (list (reg 1 6) (reg 2 0) (reg 4 9) (reg 8 2)))
    "'reg' provides access to registers using register codes")
(ok (eq? <var> (class-of (var <int>)))
    "Shortcut for creating variables creates variables")
(ok (eq? <byte> (typecode (var <byte>)))
    "Shortcut for  creating variables uses specified type")
(ok (eq? <ubyte> (typecode (var <bool>)))
    "Boolean values are represented using unsigned byte")
(let  [(i (skeleton <int>))]
  (ok (is-a? i <int>)
      "skeleton of integer is of type integer")
  (ok (is-a? (value i) <var>)
      "value of integer skeleton is a variable")
  (ok (eq? <int> (typecode (value i)))
      "value of integer skeleton is of type integer"))
(let [(s (skeleton (sequence <byte>)))]
  (ok (is-a? s (sequence <byte>))
      "skeleton of a sequence is a sequence")
  (ok (equal? (list <var> <var> <var>) (map class-of (content s)))
      "sequence skeleton consists of three variables")
  (ok (equal? (list <long> <long> <long>) (map typecode (content s)))
      "skeleton of sequence consists of long integer variables"))
(let [(m (skeleton (multiarray <int> 2)))]
  (ok (is-a? m (multiarray <int> 2))
      "skeleton of a 2D array is a 2D array")
  (ok (equal? (make-list 5 <var>) (map class-of (content m)))
      "2D array skeleton consists of five variables")
  (ok (equal? (make-list 5 <long>) (map typecode (content m)))
      "skeleton of 2D array consists of long integer variables"))
(let* [(s  (skeleton (sequence <int>)))
       (sx (parameter s))]
  (ok (eq? (value s) (value (term (term sx))))
      "sequence parameter maintains pointer")
  (ok (eq? (index sx) (index (term sx)))
      "index of parameter and index of parameters content should match")
  (ok (eq? (dimension s) (dimension sx))
      "sequence parameter should maintain dimension")
  (ok (eq? (stride s) (stride (term sx)))
      "sequence parameter should maintain stride")
  (ok (eq? (sequence <int>) (type sx))
      "sequence parameter maintains type")
  (let [(i (var <long>))]
    (ok (eq? i (index (subst (term sx) (index sx) i)))
        "substitution should replace the lookup index")
    (ok (eq? i (index (get sx i)))
        "retrieving an element by index should replace with the index")))
(let* [(m  (skeleton (multiarray <int> 2)))
       (mx (parameter m))]
  (ok (equal? (shape m) (shape mx))
      "2D array parameter should maintain the shape")
  (ok (equal? (index mx) (index (term (term mx))))
      "first index of parameter should have a match")
  (ok (equal? (index (term mx)) (index (term (term (term mx)))))
      "second index of parameter should have a match")
  (let [(i (var <long>))]
    (ok (eq? i (index (subst (term (term mx)) (index mx) i)))
      "subst should allow replacing first index")
    (ok (eq? i (index (term (subst (term (term mx)) (index (term mx)) i))))
      "subst should allow replacing second index")
    (ok (eq? (index mx) (index (subst (term (term mx)) (index (term mx)) i)))
      "replacing the second index should maintain the first one")
    (ok (eq? i (index (term (get mx i))))
      "retrieving an element should replace with the index")))
(let [(a (skeleton <byte>))
      (b  (skeleton (pointer <byte>)))]
  (ok (equal? (get a) (operand a))
      "element operand is value of element")
  (ok (equal? (ptr (typecode b) (get b)) (operand b))
      "pointer operand is pointer to element"))
(let [(out (skeleton <int>))
      (in  (skeleton <int>))]
  (ok (equal? (list (mov-signed (get out) (get in))) (code out in))
      "generate code for copying an integer")
  (ok (equal? (list (list (get out)) (list (get in)) (list (mov-signed (get out) (get in)) (RET)))
              (assemble out (list in) (parameter in) list))
      "generate code for identity function"))
(ok (equal? (list (MOV RCX RAX) (RET))
            (register-allocate (attach (code (skeleton <ulong>) (skeleton <uint>)) (RET))))
    "Use default zero-extension for 32-bit numbers")
(ok (eqv? 42 ((jit ctx (list <int>) identity) 42))
    "compile and run integer identity function")
(ok (eqv? #t ((jit ctx (list <bool>) identity) #t))
    "compile and run boolean identity function")
(let [(out (skeleton <int>))
      (in  (skeleton (pointer <int>)))]
  (ok (equal? (list (mov-signed (get out) (ptr <int> (get in))))
              (code out in))
      "generate code for reading integer from memory"))
(let [(out (skeleton (pointer <int>)))
      (in  (skeleton <int>))]
  (ok (equal? (list (mov-signed (ptr <int> (get out)) (get in)))
              (code out in))
      "generate code for writing integer to memory"))
(let [(out (parameter (skeleton (sequence <int>))))]
  (ok (eq? (iterator (term out)) (iterator out))
      "retrieve iterator pointer from tensor parameter")
  (ok (eq? (step (term out)) (step out))
      "retrieve step variable from tensor parameter")
  (ok (not (eq? (step out) (iterator out)))
      "step and iterator need to be distinct variables")
  (ok (is-a? (term (project out)) (pointer <int>))
      "projected 1D array tensor should contain pointer"))
(let [(out  (parameter (skeleton (sequence <int>))))]
  (ok (equal? (list (IMUL (step out) (stride out) (size-of (typecode out)))
                    (MOV (iterator out) (value out)))
              (setup out))
      "setup of array loop should define increment and initialise pointer")
  (ok (equal? (list (ADD (iterator out) (step out))) (increment out))
      "increment of array loop should increment the pointer")
  (ok (equal? (iterator out) (value (body out)))
      "body of loop should be rebased to the pointer")
  (ok (is-a? (term (body out)) (pointer <int>))
      "body of array loop should be a pointer object"))
(let [(in  (skeleton (pointer <byte>)))
      (out (skeleton (pointer <byte>)))]
  (ok (equal? (list (MOV DL (ptr <byte> RCX)) (MOV (ptr <byte> RAX) DL) (RET))
              (register-allocate (attach (code out in) (RET))))
      "generate code for copying a byte from one memory location to another"))
(let [(out (skeleton (sequence <int>)))
      (in  (skeleton (sequence <int>)))]
  (ok (list? (code (parameter out) (parameter in)))
      "generating code for copying an array should run without error")
  (ok (equal? (append (content out) (content in))
              (cadr (assemble out (list in) (parameter in) list)))
      "generating a method with interface for copying an array should run without error"))
(ok (equal? '(2 3 5) (to-list ((jit ctx (list (sequence <int>)) identity) (seq <int> 2 3 5))))
    "compile and run identity function for array")
(let* [(i  (var <long>))
       (op (lambda (s) (tensor (dimension s) i (get s i))))]
  (ok (equal? '(2 3 5) (to-list ((jit ctx (list (sequence <int>)) op) (seq <int> 2 3 5))))
      "compile and run trivial 1D tensor function"))
(let [(out (skeleton (multiarray <int> 2)))
      (in  (skeleton (multiarray <int> 2)))]
  (ok (list? (code (parameter out) (parameter in)))
      "generating code for copying a 2D array should run without error"))
(ok (equal? '((2 3 5) (7 9 11))
            (to-list ((jit ctx (list (multiarray <int> 2)) identity) (arr <int> (2 3 5) (7 9 11)))))
    "compile and run identity function for 2D array")
(let [(out (skeleton <int>))
      (a   (skeleton <int>))
      (b   (skeleton <int>))]
  (ok (equal? (list (mov-signed (get out) (get a)) (ADD (get out) (get b)))
              (code (parameter out) (+ (parameter a) (parameter b))))
    "generate code for adding two numbers"))
(ok (equal? 42 ((jit ctx (list <int> <int>) +) 19 23))
    "compile and run function adding two numbers")
(let [(out (skeleton <byte>))
      (in  (skeleton <int>))]
  (ok (equal? (list (MOV CL SIL) (RET))
              (register-allocate (attach (code out in) (RET))
                                 #:predefined (list (cons (get out) RCX) (cons (get in) RSI))))
      "generate code for copying part of integer (critical case MOV CL SIL)"))
(ok (eq? <sint> (type (+ (parameter (skeleton <usint>)) (parameter (skeleton <byte>)))))
  "plus operation coerces return type correctly")
(let [(out (skeleton <sint>))
      (a   (skeleton <byte>))
      (b   (skeleton <usint>))]
  (ok (equal? (list (mov-signed (get out) (get a)) (ADD (get out) (get b)))
              (code (parameter out) (+ (parameter a) (parameter b))))
      "sign-extend first number when adding")
  (ok (equal? (list (MOV DX CX) (MOVSX CX AL) (ADD DX CX) (RET))
              (register-allocate (attach (code (parameter out) (+ (parameter b) (parameter a))) (RET))))
      "sign-extend second number when adding"))
(ok (+ (parameter (skeleton (sequence <int>))) (parameter (skeleton <int>)))
    "create function from tensor and element")
(ok (+ (parameter (skeleton <int>)) (parameter (skeleton (sequence <int>))))
    "create function from element and tensor")
(ok (+ (parameter (skeleton (sequence <int>))) (parameter (skeleton (sequence <int>))))
    "create function from two tensors")
(let* [(a    (parameter (skeleton (sequence <int>))))
       (b    (parameter (skeleton <int>)))
       (f    (+ a b))
       (out  (parameter (skeleton (sequence <int>))))]
  (ok (equal? (list (IMUL (step a) (stride a) (size-of (typecode a)))
                    (MOV (iterator a) (value a)))
              (setup f))
      "setup of loop over array-scalar-function should setup looping over first argument")
  (ok (equal? (list (ADD (iterator a) (step a))) (increment f))
      "loop should increment input array iterator")
  (ok (equal? (iterator a) (value (car (arguments (body f)))))
      "body of loop should be function with element of first argument as argument")
  (ok (equal? b (cadr (arguments (body f))))
      "body of loop should maintain second argument")
  (ok (equal? (list (MOV ESI (ptr <int> RDX)) (ADD ESI ECX) (MOV (ptr <int> RAX) ESI) (RET))
              (register-allocate (attach (code (body out) (body f)) (RET))))
      "instantiate loop body for array-scalar-function"))
(let [(out (skeleton (sequence <int>)))
      (a   (skeleton (sequence <int>)))
      (b   (skeleton <int>))]
  (ok (list? (code (parameter out) (+ (parameter a) (parameter b))))
      "generating code for array-scalar operation should run without error"))
(ok (equal? '(9 10 12) (to-list ((jit ctx (list (sequence <int>) <int>) +) (seq <int> 2 3 5) 7)))
    "compile and run array-scalar operation")
(let* [(a    (parameter (skeleton <int>)))
       (b    (parameter (skeleton (sequence <int>))))
       (f    (+ a b))
       (out  (parameter (skeleton (sequence <int>))))]
  (ok (equal? (list (IMUL (step b) (stride b) (size-of (typecode b)))
                    (MOV (iterator b) (value b)))
              (setup f))
      "setup of loop over scalar-array-function should setup looping over second argument")
  (ok (equal? a (car (arguments (body f))))
      "body of loop should maintain first argument")
  (ok (equal? (iterator b) (value (cadr (arguments (body f)))))
      "body of loop should be function with element of second argument as argument")
  (ok (equal? (list (MOV ESI EDX) (ADD ESI (ptr <int> RCX)) (MOV (ptr <int> RAX) ESI) (RET))
              (register-allocate (attach (code (body out) (body f)) (RET))))
      "instantiate loop body for scalar-array-function"))
(ok (equal? '(9 10 12) (to-list ((jit ctx (list <int> (sequence <int>)) +) 7 (seq <int> 2 3 5))))
    "compile and run scalar-array operation")
(ok (equal? '(9 10 12) (to-list ((jit ctx (list <int> (sequence <byte>)) +) 7 (seq <byte> 2 3 5))))
    "sign-extend second number when adding value from pointer")
(ok (equal? '(9 14 18) (to-list ((jit ctx (list (sequence <int>) (sequence <int>)) +) (seq <int> 2 3 5) (seq <int> 7 11 13))))
    "compile and run array-array operation")
(ok (equal? '((7) (8)) (to-list ((jit ctx (list (multiarray <int> 2) <int>) +) (arr <int> (2) (3)) 5)))
    "compile and run 2D array-scalar operation")
(ok (equal? '((7) (8)) (to-list ((jit ctx (list <int> (multiarray <int> 2)) +) 5 (arr <int> (2) (3)))))
    "compile and run 2D scale-array operation")
(ok (equal? '((0 1 3) (0 2 4))
            (to-list ((jit ctx (list (sequence <byte>) (multiarray <ubyte> 2)) +) (seq -2 -3) (arr (2 3 5) (3 5 7)))))
    "compile and run operation involving 1D and 2D array")
(let [(out (skeleton <int>))
      (a   (skeleton <int>))]
  (ok (equal? (list (mov-signed (get out) (get a)) (NEG (get out)))
              (code (parameter out) (- (parameter a))))
      "generate code for negating number"))
(let [(a (parameter (skeleton (sequence <int>))))]
  (ok (equal? (term (car (arguments (body (- a))))) (term (car (arguments (- (body a))))))
      "body of array negation should have same argument as negation of array body"))
(ok (equal? -42 ((jit ctx (list <int>) -) 42))
    "Negate integer")
(ok (equal? '(-2 3 -5) (to-list ((jit ctx (list (sequence <int>)) -) (seq <int> 2 -3 5))))
    "compile and run function for negating array")
(skip (eq? <byte> (typecode (red (var <bytergb>))))
    "Red channel of byte RGB variable is a byte variable")
(skip (eq? <byte> (typecode (green (var <bytergb>))))
    "Green channel of byte RGB variable is a byte variable")
(skip (eq? <byte> (typecode (blue (var <bytergb>))))
    "Blue channel of byte RGB variable is a byte variable")
(skip (eq? <int> (to-type <int> <byte>))
    "typecast for scalar type")
(skip (eq? <int> (typecode (to-type <int> (sequence <byte>))))
    "typecast element type to integer")
(skip (eq? 1 (dimensions (to-type <int> (sequence <byte>))))
    "maintain dimension when typecasting")
(skip (equal? <sint> (type (class-of (to-type <sint> (parameter (skeleton <ubyte>))))))
    "Conversion to short integer returns a short integer")
(skip (equal? (list (MOVZX CX AL) (RET))
            (register-allocate (attach (code (to-type <sint> (parameter (skeleton <ubyte>)))) (RET))))
    "Type conversion instantiates corresponding code")
(skip (null? (code (to-type <int> (parameter (skeleton <int>)))))
    "Code for trivial type conversion is empty")
(let [(a (skeleton <int>))
      (b (skeleton <int>))
      (u (skeleton <ubyte>))
      (v (skeleton <byte>))]
  (skip (equal? (list (MOV EAX EDI) (RET))
              (assemble b (list a) (to-type <int> (parameter a))))
      "Trivial type conversion")
  (skip (equal? (list (MOVZX ECX DIL) (MOV EAX ECX) (RET))
              (assemble a (list u) (to-type <int> (parameter u))))
      "unsigned type conversion")
  (skip (equal? (list (MOVSX ECX DIL) (MOV EAX ECX) (RET))
              (assemble a (list v) (to-type <int> (parameter v))))
      "Signed type conversion")
  (skip (equal? (list (MOV CL DIL) (MOV AL CL) (RET))
              (assemble v (list a) (to-type <byte> (parameter a))))
      "Typecast integer to byte"))
(skip (equal? 42 ((jit ctx (list <int>) (cut to-type <int> <>)) 42))
    "Run trivial type conversion")
(ok (equal? 42 ((jit ctx (list <int>) +) 42))
    "plus passes through values")
(ok (equal? 9 ((jit ctx (list <int> <int> <int>) +) 2 3 4))
    "Compiling a plus operation creates an equivalent machine program")
(ok (equal? 3 ((jit ctx (list <int> <sint> <ubyte>) +) 2 -3 4))
    "Compiling a plus operation with different types creates an equivalent machine program")
(skip (eq? <intrgb> (class-of (skeleton <intrgb>)))
    "Skeleton of integer RGB has correct type")
(skip (eq? <rgb> (class-of (get (skeleton <intrgb>))))
    "Skeleton of integer RGB has RGB value")
(ok (equal? i1 ((jit ctx (list (pointer <int>)) identity)
                (make (pointer <int>) #:value (idata))))
    "Compile and run code for fetching data from a pointer")
(ok (equal? '(253 252 250) (to-list ((jit ctx (list (sequence <ubyte>)) ~) (seq 2 3 5))))
    "Bitwise not of sequence")
(skip (equal? '(-1 2 3) (to-list ((jit ctx (list (sequence <byte>)) (cut to-type <int> <>))
                                (seq <byte> -1 2 3))))
    "Typecasting a sequence should preserve values")
(ok (equal? '(0 1 2) (to-list ((jit ctx (list (sequence <int>) <byte>) -) (seq <int> 1 2 3) 1)))
    "Subtract byte from integer sequence")
(ok (equal? '(2 4 6) (to-list ((jit ctx (list (sequence <int>) <int>) *) (seq <int> 1 2 3) 2)))
    "Multiply integer sequence with an integer")
(ok (equal? '(-2 -3 -5) (to-list (- (seq <int> 2 3 5))))
    "negate integer sequence")
(ok (equal? '((-1 2) (3 -4)) (to-list (- (arr (1 -2) (-3 4)))))
    "negate 2D array")
(ok (equal? '(2 4) (to-list (+ (downsample 2 (seq 1 2 3 4)) 1)))
    "add 1 to downsampled array")
(ok (equal? '(2 4) (to-list (+ 1 (downsample 2 (seq 1 2 3 4)))))
    "add downsampled array to 1")
(ok (equal? '(2 6) (let [(s (downsample 2 (seq 1 2 3 4)))] (to-list (+ s s))))
    "add two downsampled arrays")
(ok (equal? '(2 3 5) (to-list (+ (seq <int> 2 3 5))))
    "unary plus for sequence")
(ok (equal? '(253 252 250) (to-list (~ (seq 2 3 5))))
    "bitwise negation of array")
(ok (equal? '(3 4 6) (to-list (+ (seq 2 3 5) 1)))
    "add integer to integer sequence")
(ok (equal? '(3 4 6) (to-list (+ 1 (seq 2 3 5))))
    "add integer sequence to integer")
(ok (equal? '(3 5 9) (to-list (+ (seq 2 3 5) (seq 1 2 4))))
    "add two sequences")
(ok (equal? '(-3 -2 -1) (to-list (- (seq -1 0 1) 2)))
    "element-wise subtract integer from a sequence")
(ok (equal? '((0 1 2) (3 4 5)) (to-list (- (arr (1 2 3) (4 5 6)) 1)))
    "subtract 1 from a 2D array")
(ok (equal? '((6 5 4) (3 2 1)) (to-list (- 7 (arr (1 2 3) (4 5 6)))))
    "subtract 2D array from integer")
(ok (equal? '((1 1 2) (3 4 5)) (to-list (- (arr (2 3 5) (7 9 11)) (arr (1 2 3) (4 5 6)))))
    "subtract 2D array from each other")
(ok (equal? '(((-1 2 -3) (4 -5 6))) (to-list (- (arr ((1 -2 3) (-4 5 -6))))))
    "negate 3D array")
(ok (equal? '((3 4 5) (7 8 9)) (to-list (+ (seq 0 1) (arr (3 4 5) (6 7 8)))))
    "add 1D and 2D array")
(ok (equal? '((3 4 5) (7 8 9)) (to-list (+ (arr (3 4 5) (6 7 8)) (seq 0 1))))
    "add 2D and 1D array")
(ok (equal? '(((2 3 4) (5 6 7))) (to-list (+ (arr ((1 2 3) (4 5 6))) 1)))
    "add scalar to 3D array")
(ok (equal? '(((2 3 4) (5 6 7))) (to-list (+ 1 (arr ((1 2 3) (4 5 6))))))
    "add 3D array to scalar")
(ok (equal? '(((2 4 6) (8 10 12))) (let [(m (arr ((1 2 3) (4 5 6))))] (to-list (+ m m))))
    "add two 3D arrays")
(ok (equal? '((((3 3) (3 3)) ((3 3) (3 3))) (((3 3) (3 3)) ((3 3) (3 3))))
            (to-list (+ (arr (((2 2) (2 2)) ((2 2) (2 2))) (((2 2) (2 2)) ((2 2) (2 2)))) 1)))
    "add 1 to 4D array")
(ok (equal? '(6 9 15) (to-list (* (seq 2 3 5) 3)))
    "multiply sequence with a number")
(let [(s (var <int>))
      (u (var <uint>))
      (n (var <byte>))]
  (ok (equal? RCX (get-reg (shl s n)))
      "shl blocks RCX register")
  (ok (equal? (list (mov-unsigned CL n) (SHL u CL)) (filter-blocks (shl u n)))
      "shl uses SHL for unsigned input")
  (ok (equal? (list (mov-unsigned CL n) (SAL s CL)) (filter-blocks (shl s n)))
      "shl uses SAL for signed input")
  (ok (equal? (list (mov-unsigned CL n) (SHR u CL)) (filter-blocks (shr u n)))
      "shl uses SHR for unsigned input")
  (ok (equal? (list (mov-unsigned CL n) (SAR s CL)) (filter-blocks (shr s n)))
      "shl uses SAR for signed input"))
(ok (equal? '(2 4 6) (to-list (<< (seq 1 2 3) 1)))
    "left-shift sequence")
(ok (equal? '(1 2 3) (to-list (>> (seq 4 8 12) 2)))
    "right-shift sequence")
(ok (equal? '(1 4) (to-list (duplicate (project (roll (arr (1 2 3) (4 5 6)))))))
    "'duplicate' creates copy of slice")
(ok (let [(m (make (multiarray <int> 2) #:shape '(6 4)))] (eq? m (ensure-default-strides m)))
    "'ensure-default-strides' should do nothing by default")
(ok (let [(m (make (multiarray <int> 2) #:shape '(6 4)))] (equal? '(1 4) (strides (ensure-default-strides (roll m)))))
    "'ensure-default-strides' should create a compact clone if the input is not contiguous")
(ok (equal? '(3 0 1) (to-list (& (seq 3 4 5) 3)))
    "element-wise bit-wise and")
(ok (equal? '(3 7 7) (to-list (| 3 (seq 3 4 5))))
    "element-wise bit-wise or")
(ok (equal? '(1 7 1) (to-list (^ (seq 2 3 4) (seq 3 4 5))))
    "element-wise bit-wise xor")
(let [(a (var <int>))
      (r (var <bool>))]
  (ok (equal? (list (TEST a a) (SETE r)) (test-zero r a))
      "generate code for comparing with zero"))
(ok (eq? <int> (to-type <int> <byte>))
    "typecast for scalar type")
(ok (eq? (sequence <int>) (to-type <int> (sequence <byte>)))
    "typecast element-type of array type")
(ok (equal? '(#f #t #f) (to-list (=0 (seq -1 0 1))))
    "compare bytes with zero")
(ok (equal? '(#t #f #t) (to-list (!=0 (seq -1 0 1))))
    "check whether bytes are not zero")
(ok (equal? '(#f #f #f #t) (to-list (&& (seq #f #t #f #t) (seq #f #f #t #t))))
    "element-wise 'and'")
(ok (equal? '(#f #t #t) (to-list (&& (seq 0 1 2) 1)))
    "element-wise 'and' with integer input")
(ok (equal? '(#f #t #t) (to-list (&& (seq 0 1 2) #t)))
    "element-wise 'and' with mixed input")
(ok (equal? '(#f #t #f #f) (to-list (&& (seq #f #t #t #t) (seq #t #t #t #f) (seq #t #t #f #f))))
    "element-wise and with three arguments")
(ok (equal? '(#f #t) (to-list (&& (seq #f #t) #t)))
    "element-wise and with array and boolean argument")
(ok (equal? '(#f #t #t #t) (to-list (|| (seq #f #t #f #t) (seq #f #f #t #t))))
    "element-wise or")
(skip (equal? '(#f #t #f) (to-list (! (seq #t #f #t))))
    "element-wise not for booleans")
(skip (equal? '(1 2 -3) (to-list (/ (seq 3 6 -9) 3)))
    "element-wise signed byte division")
(skip (equal? '(2 3 0 1) (to-list (% (seq 7 8 5 6) 5)))
    "element-wise modulo")


; ------------------------------------------------------------------------------
(skip (equal? '(0 2 2) (to-list ((jit ctx (list (sequence <int>) <int>) &) (seq <int> 1 2 3) 2)))
    "Bitwise and of sequence and number")
(skip (equal? '(3 2 3) (to-list ((jit ctx (list (sequence <int>) <int>) |) (seq <int> 1 2 3) 2)))
    "Bitwise or of sequence and number")
(skip (equal? '(3 0 1) (to-list ((jit ctx (list (sequence <int>) <int>) ^) (seq <int> 1 2 3) 2)))
    "Bitwise xor of sequence and number")
(skip (equal? 12 ((jit ctx (list <int> <int>) <<) 3 2))
    "Compile program shifting 3 to the left by 2")
(skip (equal? '(4 8 12) (to-list ((jit ctx (list (sequence <int>) <ubyte>) <<) (seq <int> 1 2 3) 2) ) )
    "Shift-left sequence")
(skip (equal? '(8 4 2) (to-list ((jit ctx (list <int> (sequence <ubyte>)) >>) 16 (seq <ubyte> 1 2 3))))
    "Shift-right using sequence")
(skip (equal? '(#f #t #f) (to-list ((jit ctx (list (sequence <int>) <int>) =) (seq <int> 1 2 3) 2)))
    "Element-wise equal comparison")
(skip (equal? '(#t #f #t) (to-list ((jit ctx (list (sequence <int>) <int>) !=) (seq <int> 1 2 3) 2)))
    "Element-wise not-equal comparison")
(skip (equal? '(#f #f #f #t) (to-list ((jit ctx (list (sequence <bool>) (sequence <bool>)) &&)
                                     (seq #f #t #f #t) (seq #f #f #t #t))))
    "element-wise and")
(skip (not ((jit ctx (make-list 3 <bool>) (cut && <...>)) #f #t #t))
    "&& with three boolean arguments")
(skip (equal? '(#f #t #t #t) (to-list ((jit ctx (list (sequence <bool>) (sequence <bool>)) ||)
                                     (seq #f #t #f #t) (seq #f #f #t #t))))
    "element-wise or")
(skip (equal? '(#t #f #f) (to-list ((jit ctx (list (sequence <ubyte>) <ubyte>) <) (seq 3 4 5) 4)))
    "element-wise lower-than")
(skip (equal? '(#t #t #f) (to-list ((jit ctx (list (sequence <ubyte>) <ubyte>) <=) (seq 3 4 5) 4)))
    "element-wise lower-equal")
(skip (equal? '(#f #f #t) (to-list ((jit ctx (list (sequence <ubyte>) <ubyte>) >) (seq 3 4 5) 4)))
    "element-wise greater-than")
(skip (equal? '(#f #t #t) (to-list ((jit ctx (list (sequence <ubyte>) <ubyte>) >=) (seq 3 4 5) 4)))
    "element-wise greater-equal")
(skip (equal? '(#t #f #f) (to-list ((jit ctx (list (sequence <byte>) <ubyte>) <) (seq -1 0 1) 0)))
    "element-wise lower-than of signed and unsigned bytes")
(skip (equal? '(#t #t #f) (to-list ((jit ctx (list (sequence <byte>) <ubyte>) <=) (seq -1 0 1) 0)))
    "element-wise lower-equal of signed and unsigned bytes")
(skip (equal? '(#f #f #t) (to-list ((jit ctx (list (sequence <byte>) <ubyte>) >) (seq -1 0 1) 0)))
    "element-wise greater-than of signed and unsigned bytes")
(skip (equal? '(#f #t #t) (to-list ((jit ctx (list (sequence <byte>) <ubyte>) >=) (seq -1 0 1) 0)))
    "element-wise greater-equal of signed and unsigned bytes")
(skip (equal? '(#f #f #f) (to-list ((jit ctx (list (sequence <ubyte>) <byte>) <) (seq 1 2 128) -1)))
    "element-wise lower-than of unsigned and signed bytes")
(skip (equal? '(#f #f #f) (to-list ((jit ctx (list (sequence <ubyte>) <byte>) <=) (seq 1 2 128) -1)))
    "element-wise lower-equal of unsigned and signed bytes")
(skip (equal? '(#t #t #t) (to-list ((jit ctx (list (sequence <ubyte>) <byte>) >) (seq 1 2 128) -1)))
    "element-wise greater-than of unsigned and signed bytes")
(skip (equal? '(#t #t #t) (to-list ((jit ctx (list (sequence <ubyte>) <byte>) >=) (seq 1 2 128) -1)))
    "element-wise greater-equal of unsigned and signed bytes")
(skip (equal? '(1 2 -3) (to-list ((jit ctx (list (sequence <byte>) <byte>) /) (seq 3 6 -9) 3)))
    "element-wise signed byte division")
(skip (equal? '(1200 -800 600) (to-list ((jit ctx (list <sint> (sequence <byte>)) /) 24000 (seq 20 -30 40))))
    "element-wise signed short integer division")
(skip (equal? '(120000 -80000) (to-list ((jit ctx (list <int> (sequence <byte>)) /) 2400000 (seq 20 -30))))
    "element-wise signed integer division")
(skip (equal? -1428571428 ((jit ctx (list <long> <ubyte>) /) -10000000000 7))
    "element-wise long integer division")
(skip (equal? '((1 2 3) (4 5 6))
            (to-list ((jit ctx (list (multiarray <ubyte> 2) <ubyte>) /) (arr (2 4 6) (8 10 12)) 2)))
    "element-wise division of two-dimensional array")
(skip (equal? '(127 126 125) (to-list ((jit ctx (list (sequence <ubyte>) <ubyte>) /) (seq 254 252 250) 2)))
    "element-wise unsigned byte division")
(skip (equal? '(1200 800 600) (to-list ((jit ctx (list <usint> (sequence <ubyte>)) /) 24000 (seq 20 30 40))))
    "element-wise unsigned short integer division")
(skip (equal? '(120000 80000 60000) (to-list ((jit ctx (list <uint> (sequence <ubyte>)) /) 2400000 (seq 20 30 40))))
    "element-wise unsigned integer division")
(skip (equal? 1428571428 ((jit ctx (list <ulong> <ubyte>) /) 10000000000 7))
    "unsigned long integer division")
(skip (equal? 33 ((jit ctx (list <ubyte> <ubyte>) %) 123 45))
    "unsigned byte remainder of division")
(skip (equal? 100 ((jit ctx (list <usint> <usint>) %) 1234 567))
    "unsigned short integer remainder of division")
(skip (equal? -30 ((jit ctx (list <byte> <byte>) %) -80 50))
    "signed byte remainder of division")
(skip (equal? -100 ((jit ctx (list <sint> <sint>) %) -1234 567))
    "signed short integer remainder of division")
(skip (let [(c (list (rgb 2 3 5) (rgb 3 5 7)))]
      (equal? c (to-list ((jit ctx (list (sequence <sintrgb>)) identity) (to-array <sintrgb> c)))))
    "duplicate RGB array")
(skip (equal? 2 ((jit ctx (list <ubytergb>) red) (rgb 2 3 5)))
    "extract red channel of RGB value")
(skip (equal? 3 ((jit ctx (list <ubytergb>) green) (rgb 2 3 5)))
    "extract red channel of RGB value")
(skip (equal? 5 ((jit ctx (list <ubytergb>) blue) (rgb 2 3 5)))
    "extract red channel of RGB value")
(skip (equal? '(2 3) (to-list ((jit ctx (list (sequence <ubytergb>)) red) (seq (rgb 2 3 5) (rgb 3 5 7)))))
    "extract red channel in compiled code")
(skip (equal? '(3 5) (to-list ((jit ctx (list (sequence <ubytergb>)) green) (seq (rgb 2 3 5) (rgb 3 5 7)))))
    "extract green channel in compiled code")
(skip (equal? '(5 7) (to-list ((jit ctx (list (sequence <ubytergb>)) blue) (seq (rgb 2 3 5) (rgb 3 5 7)))))
    "extract blue channel in compiled code")
(skip (equal? '(2 3) (to-list ((jit ctx (list (sequence <ubyte>)) red) (seq 2 3))))
    "extract red channel of scalar array")
(skip (equal? '(2 3) (to-list ((jit ctx (list (sequence <ubyte>)) green) (seq 2 3))))
    "extract green channel of scalar array")
(skip (equal? '(2 3) (to-list ((jit ctx (list (sequence <ubyte>)) blue) (seq 2 3))))
    "extract blue channel of scalar array")
(skip (equal? (rgb 2 3 5) ((jit ctx (list <int> <int> <int>) (lambda (r g b) (rgb r g b))) 2 3 5))
    "compose RGB value in compiled code")
(skip (equal? (list (rgb 2 3 5)) (to-list ((jit ctx (list (sequence <sintrgb>)) (cut to-type <intrgb> <>))
                                         (seq <sintrgb> (rgb 2 3 5)))))
    "convert short integer RGB to integer RGB")
(skip (equal? (list (rgb 2 3 5)) (to-list ((jit ctx (list (sequence <intrgb>)) (cut to-type <bytergb> <>))
                                         (seq <intrgb> (rgb 2 3 5)))))
    "convert integer RGB to byte RGB")
(skip (equal? (list (rgb -1 -2 3)) (to-list ((jit ctx (list (sequence <bytergb>)) -) (seq (rgb 1 2 -3)))))
    "negate RGB sequence")
(skip (equal? (list (rgb 5 7 9)) (to-list ((jit ctx (list (sequence <ubytergb>) (sequence <ubytergb>)) +)
                                         (seq (rgb 1 2 3)) (seq (rgb 4 5 6)))))
    "add RGB sequences")
(skip (equal? (list (rgb 2 3 4)) (to-list ((jit ctx (list (sequence <ubytergb>) <ubyte>) +)
                                         (seq (rgb 1 2 3)) 1)))
    "add byte RGB sequence and byte")
(skip (equal? (list (rgb 2 3 4)) (to-list ((jit ctx (list (sequence <byte>) <ubytergb>) +)
                                         (seq <byte> 1) (rgb 1 2 3))))
    "add byte sequence and RGB value")
(skip (equal? (list (rgb 2 3 4)) (to-list ((jit ctx (list <ubytergb> (sequence <byte>)) +)
                                         (rgb 1 2 3) (seq <byte> 1))))
    "add RGB value and byte sequence")
(skip (equal? (rgb 1 2 3) ((jit ctx (list <intrgb>) identity) (rgb 1 2 3)))
    "generate JIT code to return an RGB value")
(skip (equal? (rgb 5 3 1) ((jit ctx (list <ubytergb> <ubytergb>) -) (rgb 6 5 4) (rgb 1 2 3)))
    "subtract RGB values")
(skip (equal? (rgb 254 253 252) ((jit ctx (list <ubytergb>) ~) (rgb 1 2 3)))
    "invert RGB value")
(skip (equal? (rgb 6 35 143) ((jit ctx (list <ubytergb> <ubytergb>) *) (rgb 2 5 11) (rgb 3 7 13)))
    "multiply RGB values")
(skip (equal? (rgb 2 2 4) ((jit ctx (list <ubytergb> <ubyte>) &) (rgb 2 3 4) 254))
    "bitwise and for RGB values")
(skip (equal? (rgb 2 3 6) ((jit ctx (list <ubytergb> <ubyte>) |) (rgb 2 3 4) 2))
    "bitwise or for RGB values")
(skip (equal? (rgb 0 1 6) ((jit ctx (list <ubytergb> <ubyte>) ^) (rgb 2 3 4) 2))
    "bitwise exclusive-or for RGB values")
(skip (equal? (rgb 4 8 12) ((jit ctx (list <ubytergb> <ubyte>) <<) (rgb 1 2 3) 2))
    "left-shift bits of RGB value")
(skip (equal? (rgb 1 2 3) ((jit ctx (list <ubytergb> <ubyte>) >>) (rgb 4 8 12) 2))
    "right-shift bits of RGB value")
(skip (equal? (rgb 1 2 3) ((jit ctx (list <ubytergb> <ubyte>) /) (rgb 3 6 9) 3))
    "divide RGB values")
(skip (equal? (rgb 1 2 0) ((jit ctx (list <ubytergb> <ubyte>) %) (rgb 4 5 6) 3))
    "modulo RGB values")
(skip (equal? '(#t #f) (map (jit ctx (list <bool>) =0) '(#f #t)))
    "boolean negation")
(skip (equal? (rgb 2 3 5) ((jit ctx (list <byte> <byte> <byte>) rgb) 2 3 5))
    "construct RGB value in compiled code")
(skip (equal? (rgb 2 -3 256) ((jit ctx (list <ubyte> <byte> <usint>) rgb) 2 -3 256))
    "construct RGB value from differently typed values")
(skip ((jit ctx (list <ubytergb> <ubytergb>) =) (rgb 2 3 5) (rgb 2 3 5))
    "Compare two RGB values (positive result)")
(skip (not ((jit ctx (list <ubytergb> <ubytergb>) =) (rgb 2 3 5) (rgb 2 4 5)))
    "Compare two RGB values (negative result)")
(skip ((jit ctx (list <ubytergb> <ubytergb>) !=) (rgb 2 3 5) (rgb 2 4 5))
    "Compare two RGB values (positive result)")
(skip (not ((jit ctx (list <ubytergb> <ubytergb>) !=) (rgb 2 3 5) (rgb 2 3 5)))
    "Compare two RGB values (negative result)")
(skip (not ((jit ctx (list <bytergb> <byte>) =) (rgb 2 3 5) 2))
    "Compare  RGB value with scalar (negative result)")
(skip ((jit ctx (list <byte> <bytergb>) =) 3 (rgb 3 3 3))
    "Compare  RGB value with scalar (positive result)")
(skip (equal? 32767 ((jit ctx (list <usint> <usint>) min) 32767 32768))
    "get minor number of two unsigned integers")
(skip (equal? -1 ((jit ctx (list <sint> <sint>) min) -1 1))
    "get minor number of two signed integers")
(skip (equal? 32768 ((jit ctx (list <usint> <usint>) max) 32767 32768))
    "get major number of two unsigned integers")
(skip (equal? 1 ((jit ctx (list <sint> <sint>) max) -1 1))
    "get major number of two signed integers")
(skip (equal? 32768 ((jit ctx (list <sint> <usint>) max) -1 32768))
    "get major number of signed and unsigned short integers")
(let [(r (skeleton <ubyte>))
      (a (skeleton <ubyte>))
      (b (skeleton <ubyte>))]
  (skip (equal? (list (CMP DIL SIL) (MOV CL DIL) (CMOVB CX SI) (MOV AL CL) (RET))
              (assemble r (list a b) (max (parameter a) (parameter b))))
      "handle lack of support for 8-bit conditional move"))
(skip (equal? -1 ((jit ctx (list <byte> <byte>) min) -1 1))
    "get minor number of signed bytes")
(skip (equal? (list (rgb 2 2 3)) (to-list ((jit ctx (list <ubytergb> (sequence <byte>)) max)
                                         (rgb 1 2 3) (seq <byte> 2))))
    "major value of RGB and byte sequence")
(skip (equal? (list (rgb 1 2 2)) (to-list ((jit ctx (list <ubytergb> (sequence <byte>)) min)
                                         (rgb 1 2 3) (seq <byte> 2))))
    "minor value of RGB and byte sequence")
(skip (eqv? 2+3i ((jit ctx (list (complex <int>)) identity) 2+3i))
    "Return complex number")
(skip (eqv? 2 ((jit ctx (list (complex <int>)) real-part) 2+3i))
    "Extract real component in compiled code")
(skip (eqv? 3 ((jit ctx (list (complex <int>)) imag-part) 2+3i))
    "Extract imaginary component in compiled code")
(skip (equal? 2+3i ((jit ctx (list <int> <int>) (lambda (re im) (complex re im))) 2 3))
    "compose complex value in compiled code")
(skip (equal? (list 2+3i) (to-list ((jit ctx (list (sequence (complex <ubyte>))) identity) (seq 2+3i))))
    "deal with complex pointer parameter")
(skip (equal? (list 2+3i) (to-list ((jit ctx (list (sequence (complex <ubyte>))) (cut to-type (complex <int>) <>))
                                         (seq 2+3i))))
    "convert byte complex to integer complex")
(skip (equal? '(2 5) (to-list ((jit ctx (list (sequence (complex <ubyte>))) real-part) (seq 2+3i 5+7i))))
    "extract real channel in compiled code")
(skip (equal? '(3 7) (to-list ((jit ctx (list (sequence (complex <ubyte>))) imag-part) (seq 2+3i 5+7i))))
    "extract imaginary channel in compiled code")
(skip (eqv? 7+10i ((jit ctx (list (complex <int>) (complex <int>)) +) 2+3i 5+7i))
    "add complex values")
(skip (eqv? 6+3i ((jit ctx (list (complex <int>) <int>) +) 2+3i 4))
    "add complex and real value")
(skip (eqv? 5+4i ((jit ctx (list <int> (complex <int>)) +) 2 3+4i))
    "add real and complex value")
(skip (eqv? -1-4i ((jit ctx (list <int> (complex <int>)) -) 2 3+4i))
    "subtract real and complex value")
(skip (eqv? -2-3i ((jit ctx (list (complex <int>)) -) 2+3i))
    "negate complex number")
(skip (eqv? -3-4i ((jit ctx (list (complex <int>) (complex <int>)) -) 2+3i 5+7i))
    "subtract complex values")
(skip (eqv? -11+29i ((jit ctx (list (complex <int>) (complex <int>)) *) 2+3i 5+7i))
    "multiply complex numbers")
(skip (eqv? 10+15i ((jit ctx (list (complex <int>) <int>) *) 2+3i 5))
    "multiply complex numbers and real value")
(skip (eqv? 6+10i ((jit ctx (list <int> (complex <int>)) *) 2 3+5i))
    "multiply real number and complex number")
(skip (eqv? 5+7i ((jit ctx (list (complex <int>) (complex <int>)) /) -11+29i 2+3i))
    "divide complex numbers")
(skip (eqv? 2+3i ((jit ctx (list (complex <int>) <int>) /) 4+6i 2))
    "divide complex number by number")
(skip (eqv? 3-4i ((jit ctx (list <int> (complex <int>)) /) 25 3+4i))
    "divide number by complex number")
(skip (equal? (list 7+10i) (to-list ((jit ctx (list (sequence (complex <byte>)) (complex <byte>)) +) (seq 2+3i) 5+7i)))
    "add complex sequence and complex value")
(skip (eqv? 42 ((jit ctx (list <int>) real-part) 42))
    "get real part of real number")
(skip (eqv? 2-3i ((jit ctx (list (complex <int>)) conj) 2+3i))
    "complex conjugate")
(skip (eqv? 2 ((jit ctx (list <int>) conj) 2))
    "conjugate of real number")
