(use-modules (aiscm util)
             (guile-tap))
(planned-tests 17)
(toplevel-define! 'a 0)
(def-once "x" 1)
(def-once "x" 2)
(ok (eqv? 0 a)
    "'toplevel-define! should create a definition for the given symbol")
(ok (eqv? 1 x)
    "'def-once' should only create a definition once")
(ok (equal? '(1 2 3) (attach '(1 2) 3))
    "'attach' should add an element at the end of the list")
(ok (not (index 4 '(2 3 5 7)))
    "'index' returns #f if value is not element of list")
(ok (eqv? 2 (index 5 '(2 3 5 7)))
    "'index' returns index of first matching list element")
(ok (equal? '(2 3 5) (all-but-last '(2 3 5 7)))
    "'all-but-last' should return a list with the last element removed")
(ok (equal? '(1 2 3 4 5) (upto 1 5))
    "'upto should create a sequence of numbers")
(ok (equal? '(1 1 1) (expand 3 1))
    "'expand' should create a list of repeating elements")
(ok (eqv? 0 (depth 'a))
    "Depth of a symbol is zero")
(ok (eqv? 1 (depth '(a b)))
    "Depth of a list is one")
(ok (eqv? 2 (depth '(a (b) c)))
    "Depth of a list containing a list is two")
(ok (equal? '((a) (b) (c)) (flatten-n '(((a) (b)) ((c))) 2))
    "'flatten-n' can merge lists to a depth of two")
(ok (equal? '(a b c) (flatten-n '(((a) (b)) ((c))) 1))
    "'flatten-n' can merge lists to a depth of one")
(ok (equal? '((a) (b) (c)) (flatten-n '((((a)) (b)) ((c))) 2))
    "'flatten-n' preferably merges outer lists")
(ok (equal? '(1 2 3 4) (flatten '(1 (2 3) ((4)))))
    "'flatten' works like 'flatten-n' with argument 1")
(ok (equal? '(2 3 4 1) (cycle '(1 2 3 4)))
    "'cycle' should cycle the elements of a list")
(ok (equal? '(4 1 2 3) (uncycle '(1 2 3 4)))
    "'uncycle' should reverse cycle the elements of a list")
(format #t "~&")
