(use-modules (oop goops)
             (aiscm util)
             (aiscm element)
             (aiscm bool)
             (aiscm int)
             (aiscm complex)
             (aiscm rgb)
             (aiscm pointer)
             (aiscm asm)
             (aiscm jit)
             (aiscm sequence)
             (aiscm op)
             (guile-tap))
(ok (equal? '(3 3 3) (to-list (fill <byte> '(3) 3)))
    "fill byte sequence")
(ok (equal? '(3 3 3) (to-list (fill <int> '(3) 3)))
    "fill integer sequence")
(todo (equal? '(255 0 1) (to-list (to-type <ubyte> (seq 255 256 257))))
    "typecasting to smaller integer type")

; ------------------------------------------------------------------------------

(skip (equal? (list (rgb 2 4 9)) (to-list (* (rgb 2 2 3) (seq (rgb 1 2 3)))))
    "multiply RGB array")
(skip (equal? '(2 2 3 4) (to-list (max (seq <int> 1 2 3 4) 2)))
    "major value")
(skip (equal? '(1 2 2 2) (to-list (min (seq <int> 1 2 3 4) 2)))
    "minor value")
(skip (equal? (list 2+3i) (to-list (+ (seq 1+2i) 1+i)))
    "complex array plus complex value")
(skip (equal? (list 2-3i) (to-list (- (seq -2+3i))))
    "negate complex array")
(skip (equal? '(2 5) (to-list (real-part (seq 2+3i 5+7i))))
    "element-wise real part of complex array")
(skip (equal? '(3 7) (to-list (imag-part (seq 2+3i 5+7i))))
    "element-wise imaginary part of complex array")
(ok (equal? '(2 5) (to-list (real-part (seq 2 5))))
    "element-wise real part of real array")
(ok (equal? '(0 0) (to-list (imag-part (seq 2 5))))
    "element-wise imaginary part of real array")
(skip (equal? '(2 5) (to-list (conj (seq 2 5))))
    "complex conjugate of real array")
(skip (equal? '(2-3i 4-5i) (to-list (conj (seq (complex <byte>) 2+3i 4+5i))))
    "complex conjugate of complex array")
(run-tests)
