(use-modules (oop goops)
             (aiscm asm)
             (aiscm jit)
             (aiscm element)
             (aiscm int)
             (aiscm pointer)
             (aiscm sequence)
             (guile-tap))

(define ctx (make <context>))
(define i (var <long>))
(define j (var <long>))
(define s (seq <int> 2 3 5))
(define m (arr <int> (2 3 5) (7 11 13) (17 19 23)))
(define param2d (parameter (class-of m)))
(define transpose2d (indexer (car (shape param2d)) i (indexer (cadr (shape param2d)) j (get (get param2d j) i))))

(let* [(s  (skeleton (sequence <int>)))
       (sx (parameter s))]
  (ok (eq? (value s) (value (delegate (delegate sx))))
      "sequence parameter maintains pointer")
  (ok (eq? (index sx) (index (delegate sx)))
      "index of parameter and index of parameters content should match")
  (ok (eq? (dimension s) (dimension sx))
      "sequence parameter should maintain dimension")
  (ok (eq? (stride s) (stride (delegate sx)))
      "sequence parameter should maintain stride")
  (ok (eq? (sequence <int>) (type sx))
      "sequence parameter maintains type")
  (let [(i (var <long>))]
    (ok (eq? i (index (subst (delegate sx) (index sx) i)))
        "substitution should replace the lookup index")
    (ok (eq? i (index (get sx i)))
        "retrieving an element by index should replace with the index")))
(let [(out (parameter (sequence <int>)))]
  (ok (eq? (iterator (delegate out)) (iterator out))
      "retrieve iterator pointer from tensor parameter")
  (ok (eq? (step (delegate out)) (step out))
      "retrieve step variable from tensor parameter")
  (ok (not (eq? (step out) (iterator out)))
      "step and iterator need to be distinct variables")
  (ok (is-a? (delegate (project out)) (pointer <int>))
      "projected 1D array tensor should contain pointer"))
(let* [(m  (skeleton (multiarray <int> 2)))
       (mx (parameter m))]
  (ok (equal? (shape m) (shape mx))
      "2D array parameter should maintain the shape")
  (ok (equal? (index mx) (index (delegate (delegate mx))))
      "first index of parameter should have a match")
  (ok (equal? (index (delegate mx)) (index (delegate (delegate (delegate mx)))))
      "second index of parameter should have a match")
  (let [(i (var <long>))]
    (ok (eq? i (index (subst (delegate (delegate mx)) (index mx) i)))
      "subst should allow replacing first index")
    (ok (eq? i (index (delegate (subst (delegate (delegate mx)) (index (delegate mx)) i))))
      "subst should allow replacing second index")
    (ok (eq? (index mx) (index (subst (delegate (delegate mx)) (index (delegate mx)) i)))
      "replacing the second index should maintain the first one")
    (ok (eq? i (index (delegate (get mx i))))
      "retrieving an element should replace with the index")))
(ok (equal? (list (dimension param2d) (dimension (project param2d)))
            (list (dimension (project transpose2d)) (dimension transpose2d)))
    "swap dimensions when transposing")
(ok (equal? (list (stride param2d) (stride (project param2d)))
            (list (stride (project transpose2d)) (stride transpose2d)))
    "swap strides when transposing")
(ok (equal? (list (step param2d) (step (project param2d)))
            (list (step (project transpose2d)) (step transpose2d)))
    "swap step variables when transposing")
(ok (equal? (list (iterator param2d) (iterator (project param2d)))
            (list (iterator (project transpose2d)) (iterator transpose2d)))
    "swap iterator variables when transposing")
(ok (equal? (to-list (roll m))
            (to-list ((jit ctx (list (class-of m))
              (lambda (m) (indexer (car (shape m)) i (indexer (cadr (shape m)) j (get (get m j) i))))) m)))
    "switch dimensions of a 2D tensor")
(let* [(i  (var <long>))
       (op (lambda (s) (indexer (dimension s) i (get s i))))]
  (ok (equal? '(2 3 5) (to-list ((jit ctx (list (sequence <int>)) op) (seq <int> 2 3 5))))
      "compile and run trivial 1D tensor function"))
(ok (equal? (to-list s) (to-list ((jit ctx (list (class-of s)) (lambda (s) (indexer (car (shape s)) i (get s i)))) s)))
    "reconstitute a 1D tensor in compiled code")
(ok (equal? (to-list m)
            (to-list ((jit ctx (list (class-of m))
              (lambda (m) (indexer (cadr (shape m)) j (indexer (car (shape m)) i (get (get m j) i))))) m)))
    "reconstitute a square 2D tensor")
(run-tests)
