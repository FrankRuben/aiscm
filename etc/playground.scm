(use-modules (oop goops)
             (srfi srfi-1)
             (srfi srfi-26)
             (system foreign)
             (aiscm element)
             (aiscm int)
             (aiscm sequence)
             (aiscm mem)
             (aiscm pointer)
             (aiscm rgb)
             (aiscm complex)
             (aiscm obj)
             (aiscm asm)
             (aiscm jit)
             (aiscm method)
             (aiscm util)
             (guile-tap))

(define (replace-variables allocation cmd temporary)
  "Replace variables with registers and add spill code if necessary"
  (let* [(location         (cut assq-ref allocation <>))
         (primary-argument (first-argument cmd))
         (primary-location (location primary-argument))]
    (if (is-a? primary-location <address>)
      (let [(register (to-type (typecode primary-argument) temporary))]
        (compact (and (memv primary-argument (input cmd)) (MOV register primary-location))
                 (substitute-variables cmd (assq-set allocation primary-argument temporary))
                 (and (memv primary-argument (output cmd)) (MOV primary-location register))))
      (let [(spilled-pointers (filter (compose (cut is-a? <> <address>) location) (get-ptr-args cmd)))]
        (attach (map (compose (cut MOV temporary <>) location) spilled-pointers)
                (substitute-variables cmd (fold (lambda (var alist) (assq-set alist var temporary)) allocation spilled-pointers)))))))


(define (get-ptr-args cmd)
  "get variables used as a pointer"
  (filter (cut is-a? <> <var>) (append-map get-args (filter (cut is-a? <> <ptr>) (get-args cmd)))))

(define a (var <int>))
(define x (var <sint>))
(define p (var <long>))

(define allocation (list (cons a RDX) (cons p (ptr <long> RSP 32))))
(define cmd (MOV a (ptr <int> p 8)))
(define temporary RAX)
(define primary-argument (first-argument cmd))
(define primary-location (assq-ref allocation primary-argument))
(replace-variables allocation cmd temporary)

(ok (null? (get-ptr-args (MOV a 42)))
    "command without any pointer arguments")
(ok (equal? (list p) (get-ptr-args (MOV (ptr <int> p) 42)))
    "get pointer argument of a command")
(ok (null? (get-ptr-args (MOV EAX 42)))
    "compiled command without variables does not have pointer arguments")
(ok (equal? (list p) (get-ptr-args (MOV (ptr <int> p 16) 42)))
    "only return variable arguments of pointer")

(ok (equal? (list (MOV EAX 0)) (replace-variables '() (MOV EAX 0) RAX))
    "only put instruction into a list if there are no variables to replace")
(ok (equal? (list (MOV ESI ECX)) (replace-variables (list (cons a RCX)) (MOV ESI a) RAX))
    "replace input variable with allocated register")
(ok (equal? (list (MOV ECX 0)) (replace-variables (list (cons a RCX)) (MOV a 0) RAX))
    "replace output variable with allocated register")
(ok (equal? (list (MOV EDX (ptr <int> RSP 16))) (replace-variables (list (cons a (ptr <long> RSP 16))) (MOV EDX a) RAX))
    "read input variable from spill location")
(ok (equal? (list (MOV AX (ptr <sint> RSP 16)) (CMP AX 0))
            (replace-variables (list (cons x (ptr <long> RSP 16))) (CMP x 0) RAX))
    "use temporary register for first argument and fetch value from spill location")
(ok (equal? (list (MOV EAX (ptr <int> RSP 16)) (CMP EAX 0))
            (replace-variables (list (cons a (ptr <long> RSP 16))) (CMP a 0) RAX))
    "use correct type for temporary register")
(ok (equal? (list (MOV EAX (ptr <int> RSP 16)) (ADD EAX 1) (MOV (ptr <int> RSP 16) EAX))
            (replace-variables (list (cons a (ptr <long> RSP 16))) (ADD a 1) RAX))
    "read and write back argument from stack into temporary register")
(ok (equal? (list (MOV EAX 1) (MOV (ptr <int> RSP 16) EAX))
            (replace-variables (list (cons a (ptr <long> RSP 16))) (MOV a 1) RAX))
    "write output value in temporary register to the stack")
(ok (equal? (list (MOV RAX (ptr <long> RSP 32)) (MOV EDX (ptr <int> RAX 8)))
            (replace-variables (list (cons a RDX) (cons p (ptr <long> RSP 32))) (MOV a (ptr <int> p 8)) RAX))
    "use temporary variable to implement reading from pointer to pointer")
(ok (equal? (list (MOV EDX (ptr <int> RCX 8)))
            (replace-variables (list (cons a RDX) (cons p RCX)) (MOV a (ptr <int> p 8)) RAX))
    "do not use temporary variable when reading from register pointer")
(ok (equal? (list (MOV RAX (ptr <long> RSP 32)) (MOV (ptr <int> RAX 8) EDX))
            (replace-variables (list (cons a RDX) (cons p (ptr <long> RSP 32))) (MOV (ptr <int> p 8) a) RAX))
    "use temporary variable to implement writing to pointer to pointer")

; (mov-unsigned R13 (ptr <obj> (ptr <long> RSP 80) 8))
; (mov-unsigned (ptr <obj> (ptr <long> RSP 72) 8) R13)

; (replace-variables (list (cons a R13) (cons p (ptr <long> RSP 80))) (mov-unsigned a (ptr <int> p 8)) RAX)

;(diagnostics "starting test")
;(ok (equal? (list (rgb 3 4 6)) (to-list (+ (seq (rgb <obj>) (rgb 2 3 5)) 1)))
;    "convert integer RGB sequence to object RGB sequence")
;(diagnostics "test finished")
;
;(define ctx (make <context>))
;
;(define context ctx)
;(define classes (list (sequence (rgb <obj>)) (rgb <int>)))
;(define proc +)
;
;(jit context classes proc)
;
;(define vars         (map skeleton classes))
;(define expr         (apply proc (map parameter vars)))
;(define result-type  (type expr))
;(define result       (parameter result-type))
;(define types        (map class-of vars))
;(define intermediate (generate-return-code vars result expr))
;(define lst (apply assemble intermediate))
;(define results (car lst))
;(define parameters (cadr lst))
;(define instructions (caddr lst))
;(define registers default-registers)
;(define prog (flatten-code (relabel (filter-blocks instructions))))
;(define blocked (blocked-intervals instructions))
;
;(define live                 (live-analysis prog results))
;(define temporary-variables  (temporary-variables prog))
;(define intervals            (append (live-intervals live (variables prog))
;                                     (unit-intervals temporary-variables)))
;(define predefined-registers (register-parameter-locations (register-parameters parameters)))
;(define parameters-to-move   (blocked-predefined predefined-registers intervals blocked))
;(define remaining-predefines (non-blocked-predefined predefined-registers parameters-to-move))
;(define stack-parameters     (stack-parameters parameters))
;(define colors               (linear-scan-coloring intervals registers remaining-predefines blocked))
;(define callee-saved         (used-callee-saved colors))
;(define stack-offset         (* 8 (1+ (number-spilled-variables colors stack-parameters))))
;(define parameter-offset     (+ stack-offset (* 8 (length callee-saved))))
;(define stack-locations      (stack-parameter-locations stack-parameters parameter-offset))
;(define allocation           (add-stack-parameter-information colors stack-locations))
;(define temporaries          (temporary-registers allocation temporary-variables))
;(define locations            (add-spill-information allocation 8 8))
;
;(define a (var <long>))
;(define p (ptr <int> a 16))
;
;(replace-variables (list (cons a (ptr <long> RSP 32))) (MOV p 42) RAX)

(run-tests)
